CPU 功能升级迭代的顺序，CPU 的工作模式有实模式、保护模式、长模式
# 实模式
## 实模式寄存器
x86 CPU在实模式下的寄存器，表中每个寄存器都是16位的。
![[x86cpu实模式寄存器.png]]
## 实模式下访问内存
![[实模式下访问内存.png]]
**其中，代码段是由CS和IP确定的，而栈段是由SS和SP决定的。**

## 实模式中断
中断的产生：硬件中断；软件中断——INT指令
![[实模式中断表.png]]

# 保护模式
随着软件规模的增大，需要更高的计算量和更大的内存容量。
1. 16位寄存器只能表示2^16个地址，所以CPU的寄存器和运算单元都要扩展成32位。
2. 同时需要解决CPU实模式下的两个问题：CPU对任何指令不加区分地执行；CPU对访问内存的地址不加限制。
基于以上原因，CPU实现了保护模式

## 保护模式寄存器
保护模式相比于实模式，增加了一些控制寄存器和段寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是32位的，还可以单独使用低16位，这个低16位又可以拆分成两个8位寄存器。
![[保护模式寄存器.png]]
## 保护模式特权级
**特权级共四层，0为最高特权级，为内核代码所运行级别，3为最低特权级，为用户程序所运行级别**。

**段描述符中会记录访问当前段所需特权级**，程序在访问一个段时需要先构建段选择子，段选择子中中有两位专门负责表示当前程序请求访问目标段的时的特权级，即为RPL。一般来说，RPL = CPL，CPL即为当前程序所在代码段的特权级，存在CS寄存器中的后两位（因为CS 寄存器存放的就是当前代码段的段选择子）。

目标段的特权级被称为DPL，当程序访问目标段的时候，如果 DPL 特权比 CPL 和 RPL 中任何一个高，那么就会拒绝访问，从而起到了保护作用。

## 保护模式段描述符
目前为止，内存还是分段模型，要对内存进行保护，就可以转换成对段的保护。
由于**CPU的扩展导致了32位的段基地址和段内偏移**，还有一些其它信息，所以16位的段寄存器肯定放不下，所以需要找内存借空间，然后把描述一个段的信息封装成特定格式的段描述符，放在内存中。
![[保护模式段描述符.png]]
多个段描述符在内存中形成全局段描述符表，该表的基地址和长度由CPU和GDTR寄存器指示。
![[全局段描述符表.png]]
## 保护模式段选择子
CS、DS、ES、SS、FS、GS这些段寄存器，里面存放的不是一个内存段的描述符索引，而是由影子寄存器、段描述符索引、描述符表索引、权限级别组成的段选择子。
![[保护模式段选择子.png]]
其中，**影子寄存器**是靠硬件来操作的，对系统程序员不可见，是硬件为了减少性能损耗而设计的一个段描述符高速缓存，不需要每次内存访问都要去内存查表，影子寄存器也正好是64位，里面存放8字节段描述符数据。
低三位之所以能存放TI和RPL，是因为段描述符8字节对齐，第三位都为0
通常情况下，CS和SS中RPL就组成了CPL（当前权限级别），所以常常是RPL=CPL。

## 保护模式平坦模型
分段模型有很多缺陷，现代操作系统都会使用分页模型。
但是x86 CPU不能直接使用分页模型，而是要在分段模型的前提下，根据需要决定是否要开启分页。这是硬件规定，程序员无法改变。但是可以简化设计，让分段形同虚设，即保护模式的平坦模型。
CPU32位寄存器最多只能产生4GB大小的地址，一个段长度也只能是4GB,所以把所有段的基地址设为0，段长度设为0xFFFFF, 段长度粒度为4KB，这样所有的段都执行同一个（（段长度 + 1）× 粒度 - 1）字节大小的地址空间。
如下是Hello OS中的段描述符表。
```
GDT_START:
knull_dsc: dq 0
;第一个段描述符CPU硬件规定必须为0
kcode_dsc: dq 0x00cf9e000000ffff
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=1,C=1,R=1,A=0
kdata_dsc: dq 0x00cf92000000ffff
;段基地址=0，段长度=0xfffff
;G=1,D/B=1,L=0,AVL=0 
;P=1,DPL=0,S=1
;T=0,C=0,R=1,A=0
GDT_END:

GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
```

## 保护模式中断
实模式下CPU处理中断不需要做权限检查，所以可以直接通过中断向量表中的值装载CS:IP寄存器。
而保护模式下的中断需要做权限检查，还有特权级的切换，所以就需要扩展中断向量表的信息，即每个中断用一个中断门描述符表示，简称中断门。
![[保护模式中断门描述符.png]]
同样的，保护模式要实现中断，也必须在内存中有个中断向量表，同样是由IDTR寄存器指向，只不过中断向量表中的条目变成中断门描述符。
![[保护模式中断表.png]]
产生中断后，CPU首先会检查中断号是否大于最后一个中断门描述符，x86 CPU最大支持256个中断源（即中断号：0~255），然后检查描述符类型（是否是中断门或者陷阱门）、是否为系统描述符，是不是存在于内存中。
接着，检查中断门描述符中的段选择子指向的段描述符
最后做权限检查，如果CPL小于等于中断门的DPL，并且CPL大于等于中断门中的段选择子所指向的段描述符的DPL，就指向段描述符的DPL。
进一步的，CPL等于中断门中的段选择子指向的段描述符的DPL，则为同级权限不进行栈切换，否则进行栈切换。如果进行栈切换，还需要从TSS中加载具体权限的SS、ESP，当然也要对SS中段选择子指向的段描述符进行检查。
做完这一系列检查之后，CPU才会加载中断门描述符中目标代码段选择子到CS寄存器中，把目标代码段偏移加载到EIP寄存器中。
## 切换到保护模式
x86 CPU在每次加电和每次reset后，都会自动进入实模式，要想进入保护模式，就需要写代码从实模式切换到保护模式。
1. 准备全局段描述符表。
```
GDT_START:
knull_dsc: dq 0
kcode_dsc: dq 0x00cf9e000000ffff
kdata_dsc: dq 0x00cf92000000ffff
GDT_END:
GDT_PTR:
GDTLEN  dw GDT_END-GDT_START-1
GDTBASE  dd GDT_START
```
2. 加载设置GDTR寄存器，使之指向全局段描述符表
```
lgdt [GDT_PTR]
```
3. 设置CR0寄存器，开启保护模式
```
;开启 PE
mov eax, cr0
bts eax, 0                      ; CR0.PE =1
mov cr0, eax         
```
4. 进行长跳转，加载CS段寄存器，即段选择子
```
jmp dword 0x8 :_32bits_mode ;_32bits_mode为32位代码标号即段偏移
```
为什么要进行长跳转？因为无法直接或间接mov一个数据到CS寄存器，刚刚开启保护模式时，CS的影子寄存器还是实模式下的值，所以需要告诉CPU加载新的段信息。
接下来，CPU发现了CR0寄存器的第0位时1，就会按照GDTR的指示找到全局描述符表，然后根据索引值8，把新的段描述符信息加载到CS影子寄存器中。
至此，CPU真正进入保护模式，也就有了32位的处理能力。

# 长模式
长模式又名 AMD64，因为这个标准是 AMD 公司最早定义的，它使 CPU 在现有的基础上有了 64 位的处理能力，既能完成 64 位的数据运算，也能寻址 64 位的地址空间。这在大型计算机上犹为重要，因为它们的物理内存通常有几百 GB。
## 长模式寄存器
长模式相比于保护模式，增加了一些通用寄存器，并扩展通用寄存器的位宽，所有的通用寄存器都是 64 位，还可以单独使用低 32 位。这个低 32 位可以拆分成一个低 16 位寄存器，低 16 位又可以拆分成两个 8 位寄存器。
![[长模式寄存器.png]]
## 长模式段描述符
![[长模式段描述符.png]]
长模式下，CPU不再对段基地址和段长度进行检查，只对DPL进行相关检查，这个检查流程和保护模式下一样。
多个段描述符在内存中形成全局段描述符表。
## 长模式中断
保护模式下，中断门描述符中的段内偏移只有32位，但是长模式支持64位，所以需要做一定的修改。
![[长模式中断门描述符.png]]
## 切换到长模式
1. 准备长模式全局段描述符表。
```
ex64_GDT:
null_dsc:  dq 0
;第一个段描述符CPU硬件规定必须为0
c64_dsc:dq 0x0020980000000000  ;64位代码段
d64_dsc:dq 0x0000920000000000  ;64位数据段
eGdtLen   equ $ - null_dsc  ;GDT长度
eGdtPtr:dw eGdtLen - 1  ;GDT界限
     dq ex64_GDT
```
2. 准备长模式下的MMU页表，这是为了开启分页模式，切换到长模式必须要开启分页。长模式下内存地址空间的保护交割了MMU, MMU依赖页表对地址进行转换，页表由特定的格式存放在内存中，其地址由CPU的CR3寄存器指向。
```
mov eax, cr4
bts eax, 5   ;CR4.PAE = 1
mov cr4, eax ;开启 PAE
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
```
3. 加载GDTR寄存器，使之指向全局段描述符表
```
lgdt [eGdtPtr]
```
4. 开启长模式，要同时开启保护模式和分页模式，在实现长模式时定义了MSR寄存器，需要用专用的指令rdmsr、wrmsr进行读写，IA32_EFER寄存器的地址位0xC0000080，它的第8位决定了是否开启长模式。
```
;开启 64位长模式
mov ecx, IA32_EFER
rdmsr
bts eax, 8  ;IA32_EFER.LME =1
wrmsr
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0    ;CR0.PE =1
bts eax, 31
mov cr0, eax 
```
5. 进行跳转，加载CS段寄存器，刷新其影子寄存器。
```
jmp 08:entry64 ;entry64为程序标号即64位偏移地址
```
# 参考资料
[操作系统：实模式到保护模式](https://zhuanlan.zhihu.com/p/54083337)

