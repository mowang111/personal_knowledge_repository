多程序并发相关的内存问题：
程序A和程序B的内存地址冲突、保证A和B不会互相读写各自的内存空间、内存容量、扩展后CDEF等
解决方案：让所有的程序都各自享有一个从0开始到最大地址的空间，这个地址空间时独立的，是该程序私有的，其他程序既看不到也不能访问的地址空间，这个地址空间与其他程序无关，和具体的计算机也无关。

## 虚拟地址
看看最开始 Hello World 的例子，我们用 objdump 工具反汇编一下 Hello World 二进制文件，就会得到如下的代码片段、
```
00000000000004e8 <_init>:
4e8: 48 83 ec 08 sub $0x8,%rsp
4ec: 48 8b 05 f5 0a 20 00 mov 0x200af5(%rip),%rax # 200fe8 <__gmon_start__>
4f3: 48 85 c0 test %rax,%rax
4f6: 74 02 je 4fa <_init+0x12>
4f8: ff d0 callq *%rax
4fa: 48 83 c4 08 add $0x8,%rsp
4fe: c3 retq
```
上述代码中，左边第一列数据就是虚拟地址，第三列中是程序指令，如：“mov 0x200af5(%rip),%rax，je 4fa，callq *%rax”指令中的数据都是虚拟地址。
事实上，所有的应用程序开始的部分都是这样的。这正是因为每个应用程序的虚拟地址空间都是相同且独立的。
那么这个地址是由谁产生的呢？
**答案是链接器，其实我们开发软件经过编译步骤后，就需要链接成可执行文件才可以运行，而链接器的主要工作就是把多个代码模块组装在一起，并解决模块之间的引用，即处理程序代码间的地址引用，形成程序运行的静态内存空间视图。**
只不过这个地址是虚拟而统一的，而根据操作系统的不同，这个虚拟地址空间的定义也许不同，应用软件开发人员无需关心，由开发工具链给自动处理了。由于这虚拟地址是独立且统一的，所以各个公司开发的各个应用完全不用担心自己的内存空间被占用和改写。

## 物理地址
物理地址在逻辑上也是一个数据，只不过这个数据会被地址译码器等电子器件变成电子信号，放在地址总线上，地址总线电子信号的各种组合就可以选择到内存的储存单元了。
但是地址总线上的信号（即物理地址），也可以选择到别的设备中的储存单元，如显卡中的显存、I/O 设备中的寄存器、网卡上的网络帧缓存器。不过如果不做特别说明，我们说的物理地址就是指选择内存单元的地址。

## 虚拟地址到物理地址的转换
用软件方式实现太低效，用硬件实现没有灵活性，最终就用了**软硬件结合**的方式实现，它就是 MMU（内存管理单元）。MMU 可以接受软件给出的地址对应关系数据，进行地址转换。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230102133346.png)
上图中展示了 MMU 通过地址关系转换表，将 0x80000~0x84000 的虚拟地址空间转换成 0x10000~0x14000 的物理地址空间，而**地址关系转换表本身则是放物理内存中的**。

下面我们不妨想一想地址关系转换表的实现. 如果在地址关系转换表中，这样来存放：一个虚拟地址对应一个物理地址。

那么问题来了，32 位地址空间下，4GB 虚拟地址的地址关系转换表就会把整个 32 位物理地址空间用完，这显然不行。

要是结合前面的保护模式下分段方式呢，地址关系转换表中存放：一个虚拟段基址对应一个物理段基址，这样看似可以，但是因为段长度各不相同，所以依然不可取。

综合刚才的分析，系统设计者最后采用一个折中的方案，即把虚拟地址空间和物理地址空间都分成同等大小的块，也称为页，按照虚拟页和物理页进行转换。根据软件配置不同，这个页的大小可以设置为 4KB、2MB、4MB、1GB，这样就进入了**现代内存管理模式——分页模型**。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230102133632.png)

一个虚拟页可以对应到一个物理页，由于页大小一经配置就是固定的，所以在地址关系转换表中，只要存放虚拟页地址对应的物理页地址就行了。

## MMU
MMU 即内存管理单元，是用**硬件电路逻辑实现的一个地址转换器件**，它负责接受虚拟地址和地址关系转换表，以及输出物理地址。

根据实现方式的不同，MMU可以是独立的芯片，也可以是集成在其它芯片内部的，比如集成在CPU内部，x86、ARM系列的CPU就是将MMU集成在CPU核心中。
SUN公司的CPU是将独立的MMU芯片卡在总线上。

下面研究x86 CPU中的MMU。x86 CPU要想开启MMU, 就必须开启保护模式或者长模式，实模式下是不能开启MMU的。

由于保护模式的内存模型是分段模型，它并不适用于MMU的分页模型，所以我们要用保护模式的平坦模式[[CPU#保护模式平坦模型]]，这样就绕过了分段模型。这个平坦模型和长模式下忽略段基址和段长度是异曲同工的。地址产生的过程如下所示。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103084229.png)
上图中，程序代码中的虚拟地址，经过CPU的分段机制产生了线性地址，平坦模式和长模式下线性地址和虚拟地址是相等的（因为段基址为ox000000，段长度为oxffffff，称为平坦模型，即分段是失效的）。

如果不开启MMU，在保护模式下可以关闭MMU，这个线性地址就是物理地址。因为长模式下的分段弱化了地址空间的隔离，所以开启MMU是必须要做的，开启MMU才能访问内存地址空间。

### MMU页表
地址关系转换表，更专业的名字——页表。它描述了虚拟地址到物理地址的转换关系，也可以说是虚拟页到物理页的映射关系，所以称为页表。

为了增加灵活性和节约物理内存空间（因为页表是放在物理内存中的），所以页表中并不存放虚拟地址和物理地址的对应关系，只存放物理页面的地址，MMU以虚拟地址为索引取查表返回物理页面地址，而且页表是分级的，总体分为三个部分：**一个顶级页目录，多个中级页目录，最后才是页表**。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103085124.png)
从上图可看出，一个虚拟地址被分成从左至右四个位段。
第一个位段索引顶级页目录中一个项，该项指向一个中级页目录，然后用第二个位段去索引中级页目录中的一个项，该项指向一个页目录，再用第三个位段去索引页目录中的项，该项指向一个物理页地址，最后用第四个位段作该物理页内的偏移去访问物理内存。这就是MMU的工作流程。

### 保护模式下的分页
保护模式下的分页，保护模式只用32位地址空间，最多4GB-1大小的空间。
保护模式下的分页通常有两种，一种是4KB大小的页，一种是4MB大小的页。分页大小的不同，会导致虚拟地址位段的分隔和页目录的层级不同，但虚拟页和物理页的大小始终是等同的。
#### 保护模式下的分页——4KB
该分页方式下，32位虚拟地址被分成三个位段：页目录索引、页表索引、页内偏移，只有一级页目录，其中包含1024个条目，每个条目指向一个页表，每个页表中有1024个条目，其中一个条目就指向一个物理页，每个物理页4KB。正好是4GB地址空间。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103090536.png)
上图中CR3就是CPU的一个32位寄存器[[CPU#保护模式寄存器]]，MMU就是根据这个寄存器找到页目录的。下面我们看看当前分页模式下的CR3、页目录项、页表项的格式。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103090713.png)
可以看到，页目录项、页表项都是4字节32位，1024个项正好是4KB（一个页），因此他们的地址始终是4KB对齐的，所以低12位才可以另作它用，形成了页面的相关属性，如是否存在、是否可读可写、是用户页还是内核页、是否已写入、是否已访问等。

#### 保护模式下的分页——4MB页
该分页方式下，32位虚拟地址被分为两个位段：页表索引、页内偏移，只有一级页目录，其中包含1024个条目。其中一个条目指向一个物理页，每个物理页4MB，正好为4GB地址空间。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103091350.png)
CR3还是32位寄存器，只不过不再指向顶级页目录了，而是指向一个4KB大小的页表，这个页表依然要4KB地址对齐，其中包含1024个页表项，格式如下图。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103091608.png)
可以发现，4MB大小的页面下，页表项还是4字节32位，但只需要用高10位来保持物理页面的基地址就可以。因为每个物理页面都是4MB，所以低22位始终为0，为了兼容4MB页表项低8位和4KB页表项一样，只不过第7位变成了PS位，且必须是1，而PAT位移到了12位。

### 长模式下的分页
如果开启了长模式，则必须同时开启分页模式，因为长模式弱化了分段模型，而分段模型也确实有很多不足，不适应现在操作系统和应用软件的发展。
同时，长模式也扩展了 CPU 的位宽，使得 CPU 能使用 64 位的超大内存地址空间。所以，长模式下的虚拟地址必须等于线性地址且为 64 位。

长模式下的分页大小通常也有两种，4KB 大小的页和 2MB 大小的页。

#### 长模式下的分页——4KB页
该分页方式下，64位虚拟地址被分为6个位段，分别是：保留位段，顶级页目录索引、页目录指针索引、页目录索引、页表索引、页内偏移，顶级页目录、页目录指针、页目录、页表各占有4KB大小，其中各有512个条目，每个条目8字节64位大小，如下图所示。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103094403.png)
上图中的CR3已经变成64位的CPU寄存器[[CPU#长模式寄存器]],它指向一个顶级页目录，里面的顶级页目录指向页目录指针，依次类推。
需要注意的是，虚拟地址 48 到 63 这 16 位是根据第 47 位来决定的，47 位为 1，它们就为 1，反之为 0，这是因为 x86 CPU 并没有实现全 64 位的地址总线，而是只实现了 48 位，但是 CPU 的寄存器却是 64 位的。
>“这种最高有效位填充的方式，即使后面扩展 CPU 的地址总线也不会有任何影响”，想了下，应该是跟负数的表示方式有关，最高位1的是负数，位数扩充高位填1不影响其值，跟正数的高位填0不影响其值一个道理

这种最高有效位填充的方式，即使后面扩展 CPU 的地址总线也不会有任何影响，下面我们去看看当前分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项、页表项的格式，我画了一张图帮你理解
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103095032.png)
由上图可知，长模式下的 4KB 分页下，由一个顶层目录、二级中间层目录和一层页表组成了 64 位地址翻译过程。

顶级页目录项指向页目录指针页，页目录指针项指向页目录页，页目录项指向页表页，页表项指向一个 4KB 大小的物理页，各级页目录项中和页表项中依然存在各种属性位，这在图中已经说明。其中的 XD 位，可以控制代码页面是否能够运行

#### 长模式下的分页——2MB 页
在这种分页方式下，64 位虚拟地址被分为 5 个位段 ：保留位段、顶级页目录索引、页目录指针索引、页目录索引，页内偏移，顶级页目录、页目录指针、页目录各占有 4KB 大小，其中各有 512 个条目，每个条目 8 字节 64 位大小。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103095400.png)
可以发现，长模式下 2MB 和 4KB 分页的区别是，2MB 分页下是页目录项直接指向了 2MB 大小的物理页面，放弃了页表项，然后把虚拟地址的低 21 位作为页内偏移，21 位正好索引 2MB 大小的地址空间。
下面我们还是要去看看 2MB 分页模式下的 CR3、顶级页目录项、页目录指针项、页目录项的格式，格式如下图.
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230103095447.png)
上图中没有了页表项，取而代之的是，页目录项中直接存放了 2MB 物理页基地址。由于物理页始终 2MB 对齐，所以其地址的低 21 位为 0，用于存放页面属性位。

### 开启MMU
要使用分页模式就必先开启 MMU，但是开启 MMU 的前提是 CPU 进入保护模式或者长模式，开启 CPU 这两种模式的方法，我们在前面第五节课已经讲过了，下面我们就来开启 MMU，步骤如下：

1. 使 CPU 进入保护模式或者长模式。

2. 准备好页表数据，这包含顶级页目录，中间层页目录，页表，假定我们已经编写了代码，在物理内存中生成了这些数据。

3. 把顶级页目录的物理内存地址赋值给 CR3 寄存器。
```
mov eax, PAGE_TLB_BADR ;页表物理地址
mov cr3, eax
```

4. 设置 CPU 的 CR0 的 PE 位为 1，这样就开启了 MMU。
```
;开启 保护模式和分页模式
mov eax, cr0
bts eax, 0 ;CR0.PE =1
bts eax, 31 ;CR0.P = 1
mov cr0, eax
```

### MMU地址转换失败
MMU 的主要功能是根据页表数据把虚拟地址转换成物理地址，但有没有可能转换失败？

绝对有可能，例如，页表项中的数据为空，用户程序访问了超级管理者的页面，向只读页面中写入数据。这些都会导致 MMU 地址转换失败。

MMU 地址转换失败了怎么办呢？失败了既不能放行，也不是 reset，MMU 执行的操作如下。

1. MMU 停止转换地址。

2. MMU 把转换失败的虚拟地址写入 CPU 的 CR2 寄存器。

3. MMU 触发 CPU 的 14 号中断，使 CPU 停止执行当前指令。

4. CPU 开始执行 14 号中断的处理代码，代码会检查原因，处理好页表数据返回。

5. CPU 中断返回继续执行 MMU 地址转换失败时的指令。

这里你只要先明白这个流程就好了，后面课程讲到内存管理的时候我们继续探讨。