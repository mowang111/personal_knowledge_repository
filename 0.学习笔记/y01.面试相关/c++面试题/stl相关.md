# STL中resize()和reserve()的区别
+ resize(n)是调整容器的长度大小，使其能容纳n个元素，如果n小于容器的当前size,则删除多出来的元素，否则添加采用值初始化的元素
+ resize(n,t)多一个参数t, 将所有新添加的元素初始化为t
+ reserver(n)预分配n个元素的存储空间
+ 两者的区别主要是容器的capacity和size的区别
	+ size是指容器当前拥有的元素个数
	+ capacity是指容器必须分配新存储空间之前可用存储的元素总数，即预分配存储空间的大小
# STL中常见容器的实现原理
STL容器分为序列性容器和关联性容器
序列性容器
+ array:固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素
+ vector动态数组
	+ 动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。vector的数据结构其实就是三个迭代器构成的，一个指向目前使用的空间头，一个指向目前使用的空间尾，一个指向目前可用的空间尾。当有新元素插入时，如果目前容量够则直接插入；如果不够则扩充至两倍，依次类推。扩充的过程时重新申请一块连续内存，将原有数据拷贝到新空间，再释放原有空间，扩充后原有的迭代器会失效。
	+ remove()的实现原理：在遍历容器中的元素时，一旦遇到目标元素，就做上标记，然后继续遍历，知道找到一个非目标元素，用此元素将最先做标记的位置覆盖掉，同时将此目标元素所在的位置也做上标记，等待找到新的非目标元素将其覆盖。remove()不会该表其容量大小，而erase()可以改变其容量大小，通常将remove()返回的迭代器传入erase()中清除后续无用的元素。
	+ 注意事项：
		+ 插入和删除元素后，由于内存重分配则会导致迭代器全部失效；没有重分配则插入和删除之后的迭代器失效
		+ 清空vector数据时，如果保存的数据项是指针类型，需要逐项delete，否则会造成内存泄漏
		+ 频繁调用push_back的影响：向vector的尾部添加元素，很可能引起整个对象存储空间的重新分配，这个过程是耗时耗力的。C++11之后，新增emplace_back()方法，都是添加元素，但是该方法效率更高。emplace_back在内存优化方面和运行效率方面有改下，内存优化方面主要体现在就地构造（直接在容器内构造对象，不用拷贝一个再使用）+强制类型转换，由于省去了拷贝构造，效率有提高。
+ list链表：双向链表，常量性能的增删，不支持随机访问
+ deque
	+ 支持从头尾两端进行元素的插入和删除操作，没有容量的概念，因为它是动态地以【分段连续空间】组合而成，随时可以增加一段新的空间并连接起来，但是拥有复杂的迭代器结构。deque采用一块所谓的map作为主控，这里的map实际就是一块大小连续的空间，其中每一个元素都称为节点node,都指向了另一段连续线性空间，该空间是deque真正的存储空间。
	+ 实现原理
		+ 迭代器是一个类，其中迭代器中的node变量指向map的一个单元，而map中的每个单元指向当前迭代器对应的数据（缓冲区）。
		+ 当某个缓冲区头部或尾部已满时，将回到map中定位到相邻的数据缓冲区。内部分段连续实现
		+ 当插入元素时，当前位置位于首部或尾部时，直接插入；否则比较当前元素距离首部近还是尾部近，距离那边近则将当前位置那段的元素整体移动，再插入当前元素
关联性容器
+ map,multimap: 以Key建立的红黑树
+ set, multiset：红黑树，multiset支持重复，而set会去重
+ unordered_map：
	+ 所有无序容器的底层实现都是Hash Map
	+ 无序容器存储键值对时，会先申请一整块连续的存储空间，但此空间并不是来直接存储键值对，而是存储各个链表的的头指针，称之为【桶】，各个键值对真正存储位置时各个链表的节点