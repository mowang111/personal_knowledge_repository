在这层抽象背后，一个 C 程序中的各类语法结构，究竟是如何映射到机器能够识别的不同指令上的？
数据和量值是程序运行的基石。
## c语言中的量值与数据
### 变量
### 常量
用 const 关键字按照与定义变量相同语法定义的量，不也是常量吗？它与字面量常量有什么区别呢？
1. 在c语言中，使用`const`关键字修饰的变量，无法后续修改启对应或指针指向的值，称为“只读变量”，而非常量。外在表现上和字面量常量相同。
2. 最重要的不同点：**使用`const`修饰的只读变量不具有“常量表达式”的属性**，因此无法用来表示定长数组大小或使用在case语句中。
3. 常量表达式本身会在程序编译时被求值，而只读变量的值只能在程序实际运行时才得知。
4. 编译器通常不会对只读变量进行内联处理，因此其求值不符合常量表达式的特征。
```c
#include <stdio.h>
int main(void) {
  const int vx = 10;
  const int vy = 10;
  int arr[vx] = {1, 2, 3};  // [错误1] 使用非常量表达式定义定长数组；
  switch(vy) {
    case vx: {  // [错误2] 非常量表达式应用于 case 语句；
      printf("Value matched!");
      break;
    }
  }
}
```

### 数据的存储形式
+ 对于大多数计算机而言，通常其内部会使用**补码（Two’s-complement）**的格式来存放**有符号整数**, 使用直接对应的**二进制位格式**来存放**无符号整数**;
+ 使用 **IEEE-754 标准编码**格式来存放**浮点数**，也就是小数。
+ 实际上，**计算机在看待数据时，并不会区分其符号性，而符号性的差异仅体现在计算机指令操作数据时的具体使用方式上。**
#### 补码
一个补码所表示的实际数值，由其负权重位的值与正权重位的值求和而来，其中负权重位对应于最高有效位（MSB）的符号位，即该位的二进制值在计算时按负值累加。其余各位一起对应正权重位，即这些位对应的二进制值在计算时按正值累加。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20231001150225.png)
对于非负数 x，我们可以用 2w−x 来计算 −x 的 w 位表示。（相当于取反+1）

>计算机不会区分数据的符号性，符号性的差异仅由计算机指令如何使用数据而定。比如在 C 语言中，当对某类型变量进行强制类型转换时，其底层存储的数据并不会发生实质的变化，而仅是程序对如何解读这部分数据的方式发生了改变。比如下面这个例子：
```c
#include <stdio.h>
int main(void) {
  signed char x = -10;
  unsigned char y = (unsigned char)x;
  printf("%d\n", y);  // output: 246.
  return 0;
}
```

> 在 C 语言中，关于数据使用还有一个值得注意的问题：变量类型的隐式转换（Implicit Type Conversion）。C 语言作为一种相对而言的“弱类型”语言，其一大特征就是在某些特殊情况下，变量的实际类型会发生隐式转换。
> 