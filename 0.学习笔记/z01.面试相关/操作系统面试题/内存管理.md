
# 虚拟内存
## 虚拟内存引入的原因
直接使用物理内存会产生一些问题
![[直接使用物理内存的问题]]
1. **内存空间利用率的问题**：各个进程对内存的使用会导致内存碎片化，当要用malloc分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况
2. **读写内存的安全性问题**：物理内存本身时不限制访问的，任何地址都可以读写
3. **进程间的安全问题**：各个进程之间没有独立的地址空间，一个进程由于执行错误代码或是恶意代码都可以直接修改其他进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的
4. **内存读写的效率问题**：当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘中，然后将新的程序装入内存运行。由于大量数据频繁装入装出，内存的使用效率会非常低

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部存储器上，在需要时进行数据交换

## 虚拟内存的作用
+ **解决了多进程之间地址冲突的问题**。由于每个进程都有自己的页表，进程也没有办法访问其他进程的页表，所以每个进程的虚拟内存空间时相互独立的
+ **在内存访问方面，操作系统提供了更好的安全性**。页表里的页表项中除了物理地址之外，还有一些标记属性，比如控制一个页的读写权限，标记该页是否存在等。

## 虚拟地址空间
对于⼀个单⼀进程的概念，这个进程看到的将是地址从0开始的整个内存空间。虚拟存储器是⼀个抽象 概念，它为每⼀个进程提供了⼀个假象，好像每个进程都在独占主存，每个进程看到的存储器是⼀致 的，称为虚拟地址空间。
在 Linux 操作系统中，虚拟地址空间的内部⼜被分为内核空间和⽤户空间两部 分，不同位数的系统，地址空间的范围也不同。⽐如最常⻅的 32 位和 64 位系统，如下所示。虽然每 个进程都各⾃有独⽴的虚拟内存，但是每个虚拟内存中的内核地址，其实关联的都是相同的物理内存。 这样，进程切换到内核态后，就可以很⽅便地访问内核空间内存。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230219194725.png)

用户空间内存，从低到高分别是6种不同的内存段：
+ 程序文件段（.text），包括二进制可执行代码
+ 已初始化数据段（.data），包括静态常量
+ 未初始化数据段（.bss），包括未初始化的静态变量
+ 堆段，包括动态分配的内存，从低地址开始向上增长
+ 文件映射段，包括动态库、共享内存等，从低地址开始向上增长
+ 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB。当然系统也提供了参数，以便自定义大小。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230219195031.png)

## 虚拟内存实现思路
1. 在系统中为每个程序定义一个虚拟地址空间，虚拟地址空间中的地址都是连续的
2. 虚拟地址空间被分割成多个块，每块称为一个页或者页面
3. 物理内存被分成和页面大小相同的多个区域，称作页框
4. 程序加载时，可将任意一个页面放入内存中的任意一个页框
5. CPU的硬件负责将虚拟地址映射到物理内存中的地址（页面->页框）
6. 程序的整个地址空间无需全部载入物理内存，还有部分暂时存储在外存上，需要时再换入内存
7. 如果程序引用到一部分不在虚拟地址时，会发生缺页中断，由操作系统负责将缺失的页面加载入页框中，并重新执行失败的指令

### 内存管理单元（MMU）
将CPU中负责地址转换的部分统称为内存管理单元。利用地址转换，操作系统就可以控制进程的所有内存访问，确保访问在地址空间的界限内。这个技术的关键时硬件支持，硬件可以快速地将内存访问操作中的虚拟地址转换为物理地址。
对于一个页式内存地址转换，有三个步骤：
1. 把虚拟内存地址，切分成页号和偏移量；
2. 根据页号，从页表里面查询对应的物理页号；
3. 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址

### TLB的原理
现代操作系统中，页表的个数是很多的，而每次执行语句时都需要先查找页表，将虚拟地址转换为物理内存地址。这部分切换的时间开销很大。因此，解决方案时设置一个转换检测缓冲区（TLB, translation-lookaside buffer），是MMU(内存管理单元)的一部分。它提供一个缓冲区，记录虚拟页面号到物理页框号的映射，这样可以在O(1)的时间里直接将虚拟页面映射到物理页框，不需要访问页表，从而节省时间

## 分段和分页
进程是操作系统资源分配的最小单元。操作系统分配给进程的内存空间种包含五种段：数据段、代码段、BSS、堆、栈
+ 数据段：存放程序中的静态变量和已初始化且不为0的全局变量
+ 代码段：存放可执行文件的操作指令，代码段是只读的，不可进行写操作。这部分的区域在运行前已知其大小。
+ BSS段（Block Started By Symbol）:存放未初始化的全局变量，在变量使用前由运行时初始化为0
+ 堆：存放进程运行中被动态分配的内存，其大小不固定
+ 栈：存放程序中的临时的局部变量和函数的参数值

分段机制，可以更好的控制不同段的属性，有利于内存的组织安排，可以对不同的属性代码、数据进行更方便的管理，程序运行地址和物理地址的隔离

但是物理内存使用效率地下的问题依然没有得到解决，因为分段机制映射的是一片连续的物理内存

于是利用【分页】的方法把段空间更细分了，粒度更小，此时物理内存被划分为一小块一小块，每块被称为帧（Frame）。分配内存时，帧是分配的最小单位。

在分段的方法中，每次程序运行都会被全部加载到虚拟内存中；而分页方法不同，单位不是整个程序，而是某个"页"，一段虚拟地址空间组成的某一页映射到一段物理地址空间组成的某一页。它将少部分要运行的代码加载到虚拟内存中，通过映射在物理内存中运行，从而提高了物理内存的使用率

虚拟内存页的三种状态：
+ 未分配：未被操作系统分配或者创建，未分配的虚拟页不存在任何数据和代码与它们关联，因此不占用磁盘资源
+ 已缓存：表示的是物理内存中已经为该部分分配的，存在虚拟内存和物理内存映射关系的
+ 未缓存：指的是已经加载到虚拟内存中的，但是未在物理内存中建立映射关系

## 页表
虚拟内存中的一些虚拟页是要缓存到物理内存中才能被执行的，因此操作系统存在一种机制用来判断
+ 某个虚拟页是否被缓存在物理内存中
+ 还需要知道这个虚拟页存放在磁盘上的哪个位置，从而在物理内存中选择空闲页或者更新缓存页，并将需要的虚拟页从磁盘复制到物理内存中。
+ 这些功能是由软硬件结合完成，其存放在【物理内存】中一个叫【页表】的数据结构中
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230215152345.png)

虚拟内存和物理内存的映射通过页表（page table）来实现。每个页表实际上是一个数组，数组中的每个元素称为页表项（PTE, page table entry），每个页表项负责把虚拟页映射到物理页上。在物理内存中，每个进程都有自己的页表

因为有一个表可以查询，就会遇到两种情况，一种是【命中（page hit）】,另一种则是【未命中（page fault）】
+ 命中的时候，及访问到页表中的蓝色条目地址时，因为是已缓存的数据，可以直接发访问
+ 不命中的时候，即访问到page table中的灰色条目是，需要缺页置换

## 内存管理方法
### 段式内存管理
按照逻辑意义将程序分为若干段，每个段独立载入到内存的不同区间中，通过段表对物理地址进行映射
优点：按照逻辑关系进行划分，能产生连续的内存空间
缺点：每个段必须连续、全部加载到内存中，会产生内存碎片；连续空间不足，与硬盘交互导致内存交换的效率低的问题。

### 页式内存管理
页式管理把内存空间按页的大小划分成若干页面，然后把页式虚拟地址与内存地址建立一一对应的页表。而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理地址、更新进程页表，最后再返回用户空间，恢复进程的运行
优点：不存在外部碎片，只在每个进程的最后一个页中存在内部碎片
缺点：程序全部装入内存，要求有相应的硬件支持。例如地址转换模块缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。这增加了机器成本和系统开销

### 段页式内存管理
把分段和分页两种方式结合，先把程序按照逻辑意义分成段，然后每个段再分成固定大小的页。这样，地址结构就由段号、段内页号和页内位移组成。Linux系统主要采用了分页管理，但是由于Intel处理器的发展史，Linux无法避免分段管理。于是Linux就把所有的段的基地址设为0，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了CPU逻辑地址的概念，所以段制备拥有访问控制和内存保护

## 页面放置算法
+ 最佳适应算法
	+ 检查所有空闲分区，选择和新进程申请内存大小最接近的空闲分区
	+ 优点：该算法保留⼤的空闲区 
	+ 缺点：检查所有空闲分区需要时间。外部碎⽚多：会留下许多难以利⽤的，很⼩的空闲分区，称为外部 碎⽚。可以采⽤内存紧凑的⽅法，将被使⽤的分区都移动到⼀起，减少外部碎⽚。但是移动内存中的代 码和数据也需要很多时间
+ 最差适应算法
	+ 每次为进程分配分区时，都选择最⼤的空闲分区分配。最差适应算法使链表中的结点⼤⼩趋于均匀，适⽤于请求分配的内存⼤⼩范围较窄的系统
	+ 优点：该算法保留⼩的空闲区，尽量减少外部碎⽚的产⽣ 内存管理⽅法 
	+ 缺点：检查⽐较所有的空闲区间需要时间；系统中不会存在⾯积很⼤的空闲区间，难满⾜⼤进程的要求
+ 首次适应算法
	+ 只要发现能⽤的分区就分配。这种⽅法⽬的在于减少查找时间。为适应这种算法，空 闲分区表（空闲区链）中的空闲分区要按地址由低到⾼进⾏排序。该算法优先使⽤低址部分空闲 区，在低址空间造成许多⼩的空闲区，在⾼地址空间保留⼤的空闲区
	+ 优点：可以剩下⼤的分区 缺点：外部碎⽚多，集中在低址部分；并且每次查找都是从低址部分开始的，这⽆疑⼜会增加查找可⽤ 空闲分区时的开销
+ 下次适应算法
	+ 操作系统记住接下来该检查的空闲分区的位置，给进程分配分区时，系统从记录的分 区开始依次向后查找直到碰到能⽤的分区为⽌，如果到链表尾还没有找到，就再从头开始
	+ 很难剩下⾯积很⼤的区间，会使剩余分区的⼤⼩⽐较平均

## 页面置换算法
当出现缺页异常需要调入新页面而内存已满时，选择被置换的物理页面，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页

+ 最佳⻚⾯置换算法：置换在「未来」最⻓时间不访问的⻚⾯。最佳⻚⾯置换算法作⽤是为了衡量你 的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是⾼效的。
+ 先进先出置换算法（FIFO）：直接换出最早装⼊的⻚⾯。 优点：简单 缺点：性能不是很好，因为它淘汰的可能是常⽤的⻚⾯ 适⽤场景：数据只⽤⼀次，将来不太可能使⽤；
+ 时钟置换法（Clock）：将⻚⾯保存在环形链表中，只需要后移队头指针。如果该位为 0，淘汰该 ⻚；如果该位为 1，将该位设为 0 优点：避免了移动链表节点的开销
+ 最近最少使⽤法（LRU：Least Recently Used）：优先淘汰最久未被访问的⻚⾯。根据局部性原 理，⼀个进程在⼀段时间内要访问的指令和数据都集中在⼀起。如果⼀个⻚⾯很久没有被访问，那 么将来被访问的可能性也⽐较⼩。
	+ 优点：实验证明 LRU 的性能较好，能够降低置换频率 
	+ 缺点：存在缓存污染问题，即由于偶发性或周期性的冷数据批量查询，热点数据被挤出去，导致缓存命 中率下降 
	+ 适⽤场景：访问分布未知的情况
+ 最少频率使⽤法（LFU：Least Frequently Used）：优先淘汰最近访问频率最少的数据。 
	+ 优点：能够避免缓存污染问题对 LRU 的命中影响 
	+ 缺点：存在访问模式问题，即如果访问内容发⽣较⼤变化，LFU 需要⽤更⻓的时间来适应，导致缓存命 中率下降；维护相关数据结构的开销⼤
+ 随机淘汰法

## 磁盘调度算法
为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做到的。寻道的时间时磁盘访问最耗时的部分，如果请求顺序优化得当，比如可以节省一些不必要的寻道时间，从而提高磁盘的访问性能
1. 先来先服务 
2. 最短寻道时间优先（Shortest Seek First，SSF）算法：优先选择从当前磁头位置所需寻道时间最 短的请求。但这个算法可能存在某些请求的饥饿 
3. 扫描算法：为了防⽌上述饥饿问题，可以规定：磁头在⼀个⽅向上移动，访问所有未完成的请求， 直到磁头到达该⽅向上的最后的磁道，才调换⽅向，这就是扫描（Scan）算法。 
4. 循环扫描（Circular Scan, CSCAN ）：只有磁头朝某个特定⽅向移动时，才处理磁道访问请求， ⽽返回时直接快速移动⾄最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不 处理任何请求，该算法的特点，就是磁道只响应⼀个⽅向上的请求。 
5. LOOK 与 C-LOOK算法：扫描算法和循环扫描算法，都是磁头移动到磁盘「最始端或最末端」才 开始调换⽅向。优化的思路就是磁头在移动到「最远的请求」位置，然后⽴即反向移动。

## 内存不足会发生什么

主要有两类内存可以被回收，而且它们回收的方式也不同。文件也和匿名页的回收都是基于LRU算法，也就是优先回收不常用的访问的内存。
+ 文件页：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫做文件页。大部分文件页都可以直接释放内存，以后如果有需要，再从磁盘重新读取就可以。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。所以回收干净页的方式是直接释放内存，回收脏页的方式是写写回磁盘后再释放内存。
+ 匿名页：这部分内存没有实际载体，不像文件缓存有硬盘文件这样一个载体，比如堆、栈数据等。这部分内存很可能还要再次被访问，所以不能直接释放内存，它们的回收方式是通过Linux的Swap机制，Swap会把不常访问的内存先写到磁盘中，然后释放这些内存。再次访问这些内存时，重新从磁盘读入内存即可


