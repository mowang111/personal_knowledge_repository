操作系统的特性：并发性、共享性、虚拟性、异步性
## Windows和Linux内核差异
对于内核的架构一般由三种类型：
+ 宏内核，包含多个模块，整个内核像一个完整的程序
+ 微内核，有一个最小版本的内核，一些模块和服务则由用户态管理
+ 混合内核，是宏内核和微内核的结合体，内核中抽象出了微内核的概念，也就是内核中会有一个小型的内核，其他模块就在这个基础上搭建，整个内核是个完整的程序
Linux的内核设计是采用了宏内核，Window的内核设计则是采用了混合内核
Linux可执行文件格式叫做ELF，Windows可执行文件格式叫做PE。

## 键盘敲入字母时，发送了什么
+ 键盘控制器产生扫描码数据，将其缓冲在【键盘控制器的寄存器】中，然后键盘控制器通过总线给CPU发送中断请求
+ CPU收到中断请求后，操作系统会【保存被中断进程的上下文】，然后【调用键盘的中断处理程序】
+ 键盘的中断处理程序是在键盘驱动程序初始化时注册的，其功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符
+ 得到显示字符的ASCII码后，会把ASCII码放到【读缓冲区队列】，显示设备的驱动程序会定时从【读缓冲区队列】读取数据放到【写缓冲区队列】，最后把【写缓冲区队列】的数据一个一个写入到显示设备控制器的寄存器中的数据缓冲区，最后将这些数据显示到屏幕上
+ 显示出结果后，恢复被中断进程的上下文

# 用户态和内核态
## 陷入内核态的方式：
1. 系统调用
	1. 系统调用是用户进程主动发起的操作。发起系统调用，陷入内核，由操作系统执行系统调用，然后再返回到进程。
	2. 系统调用实质上就是函数调用，只不过调用的是系统函数，处于内核态而已。
	3. 用户在调用系统调用时会向内核传递一个系统调用号，然后系统调用处理程序通过此号从系统调用表中找到相应的内核函数执行，最后返回。
2. 异常
	1. 异常包括程序运算引起的各种错误如除0、缓冲区溢出、缺页等。
	2. 异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。
	3. 异常是同步的
3. 中断
	1. 中断包括I/O设备发出的I/O中断、各种定时器引起的时钟中断、调试程序中设置的断点引起的调试中断等。
	2. 中断由处理器外部的【硬件】产生，不是执行某条指令的结果，也无法预测发生的时机。
	3. 由于中断独立于当前执行的程序，因此中断是异步事件

|                          | 陷阱                     | 中断            | 异常           |
| ------------------------ | ------------------------ | --------------- | -------------- |
| 来源                     | 处理机内部/陷阱指令      | 处理机外部/硬件 | 处理机内部     |
| 是否是执行当前指令的结果 | 是                       | 否              | 是             |
| 同步/异步                | 同步                     | 异步            | 同步           |
| 是否陷入内核             | 是                       | 是              | 是             |
| 处理程序位置             | 中断描述符表->系统调用表 | 中断描述符表    | 中断描述符表   |
| 返回行为                 | 下一条指令               | 下一条指令      | 当前指令或终止 |
| 是否会导致进程终止       | 否                       | 否              | 可能           |

## 执行系统调用时OS状态
1. 用户运行库函数（系统调用的封装），函数里面其实执行的int 0x80指令。系统调用先把系统调用号保存在eax寄存器中，然后执行int 0x80指令
2. int 0x80指令先进行切换堆栈，找到进程的堆栈，将寄存器值压入到内核栈中。
3. 然后查找相应中断向量表的中断处（system_call）并调用
4. 随后system_call从系统调用表中找到相应的系统调用进行执行，调用结束后从system_call中返回

## CPU中断
### CPU中断是什么？
1. 计算机处于执行期间，系统内发生了非预期的急需处理的事件
2. CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序
3. 处理完毕后返回原来被中断处继续执行

### CPU中断的作用？
1. 可以使CPU和外设同时工作，使系统可以及时地响应外部事件
2. 可以允许多个外设同时工作，大大提高CPU的利用率
3. 可以使CPU及时处理各种软硬件故障

## 零拷贝
零拷贝指的是，从一个存储区域到另一个存储区域的【拷贝任务没有CPU参与】。零拷贝通常用于网络文件的传输，以减少CPU消耗和内存带宽占用，减少用户空间（用户可以操作的内存缓存区域）与CPU内核空间（CPU可以操作的内存缓存区域以及寄存器）的拷贝过程，减少用户上下文与CPU内核上下文的切换，提高系统效率。

传统拷贝方式：发生4次空间切换（1、4、5、7）,发生4次copy（3、4、5、6）,其中有2次CPU（4，5）参与
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230219121138.png)

零拷贝方式：零拷贝是通过sendfile系统调用实现的。发生2次空间切换（1、6）,发生3次copy(3,4,5)，没有cpu参与。（mmap零拷贝在此基础上增加用户空间与内核空间中内核缓冲区的共享，会多2次空间切换）
DMA(Direct Memory Access，直接内存存取)，它允许不同速度的硬件装置来沟通，而不需要CPU的大量中断负载。DMA主要是可以使得外围设备可以直接访问内存，从中减少CPU参与。DMA方式（优先级高于中断）主要适用于一些高速的I/O设备。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230219121554.png)

### 传输文件的时候，需要根据文件大小来使用不同的方式：
+ 传输大文件的时候，使用【异步I/O+直接I/O】。因为可能由于PageCache被大文件占据，而导致热点小文件无法利用到PageCache，并且大文件的缓存命中率不高。
+ 传输小文件时，则使用【零拷贝技术】


# 进程、线程、协程
## 进程的组成？
进程就是运行起来的程序的抽象
进程由程序控制块（PCB)、程序段、数据段组成
操作系统通过PCB来管理进程，因此PCB中存放操作系统对进程管理的各种信息，如进程描述信息，进程控制和管理信息，资源分配清单相关信息等。
程序段：程序代码存放的位置
数据段：程序运行时使用，产生的运算数据。如全局变量，局部变量，宏定义的常量就存放在数据段内。

### PCB的存储信息：
+ 进程id。系统中每个进程有唯一的id，非负整数。
+ 进程的状态。有就绪、运行、阻塞、挂起、停止等状态
+ 进程切换时需要保存和恢复的一些CPU寄存器
+ 描述虚拟地址空间大大信息
+ 描述控制终端的信息
+ 当前工作目录
+ umask掩码
+ 文件描述符表，包含很多执行结构体的指针
+ 和信号相关的信息
+ 用户id和组id
+ 会话（Session）和进程组
+ 进程可以使用的资源上限（Resource Limit）

## 进程和线程的区别？
+ 进程时资源分配的基本单位（包括内存，打开的文件），线程是CPU调度的基本单位
+ 线程和进程相似，同样具有三种基本状态：就绪、阻塞、运行，同样具有状态之间的转换关系
+ 线程能减少并发执行的时间和空间开销，具体体现在：
	+ 线程创建时间比进程快：进程创建需要大量的资源管理信息，如内存管理，文件管理，而线程不需要关心，因为线程共享这些信息
	+ 线程终止时间比进程快：线程释放的资源比进程少
	+ 线程切换更快：线程有相同的地址空间，不需要切换表
	+ 线程数据传递不需要经过内核，因为线程之间共享资源
+ 进程的私有资源：地址空间、全局变量、堆、栈、寄存器、程序计数器
  线程的私有资源：栈、寄存器、程序计数器

### 一个进程最多可以创建多少个线程？
+ 进程的虚拟内存空间上限，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需要的栈空间就要越大，那么虚拟内存就会占用的越多
+ 系统参数限制，虽然Linux没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程数量

## 操作系统是如何进行进程管理的？
首先，我简单说一下进程从创建到终止的大致过程
当某个进程被创建后，操作系统会按照下面步骤对其进行初始化
+ 给新进程分配一个进程ID
+ 分配内存空间
+ 初始化PCB
+ 进入就绪队列
进入就绪队列后，进程的状态就变为就绪态，操作系统会经过某种调度算法，当调度到该进程时，该进程进入运行态，如果进程中有事件需要等待，例如IO操作，则进程进入阻塞态，IO设备可用时进入就绪态，当被调度后，重新进入运行态，进程完成后，进入终止态
在七状态模型中，增加了挂起态，当排队的进程过多，为解决内存占用问题，将一部分内存中的进程交换到磁盘中，这些别交换到磁盘中的进程，会进入挂起状态，可进一步分为就绪/挂起，阻塞/挂起。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230214223515.png)


## 进程/CPU调度算法
1. 先来先服务（First Come First Serverd）：对短作业不公平；对I/O密集型进程不利
2. 最短作业优先（Shortest Job First, SJF）:对长作业不公平；可能导致饥饿问题
3. 最高响应比优先（Highest Response ratio Next, HRRN）：作业允许所需时间越小，作业等待时间越长，响应比越大。同时考虑了等待时间和执行时间，既优先考虑短作业，也防止长作业无限等待的饥饿
4. 时间片轮转（Round Robin, RR）：优点：没有饥饿问题。问题：若时间片小，进程切换频繁，吞吐量低；若时间片长，则响应时间过长，实时性得不到保证
5. 最高优先级调度
6. 多级反馈队列（Multilevel Feedback Queue, MFQ）：优先级高的队列先执行；优先级越高，时间片越短；如果一个进程在当前队列规定的时间片内无法执行完毕，则移动到下一个队列的队尾。缺点：也有可能出现饥饿问题，比如不断有新的更高的优先级加入。可在一定时间后全部提升到优先级高的队列解决。

## 进程间的通信方式
信号、管道、信号量、共享内存、消息队列

### 信号
信号时系统为响应某些条件而产生的一个事件，接收到该信号的进程可以采取事先自定义的行为
#### 信号来源：
1. 硬件来源。如按下CTRL+C等
2. 软件来源。如Kill命令等
#### 进程如何发送信号：
1. 使用系统调用将信号放到目标进程的信号队列中
2. 如果目标进程处于未执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。
#### 进程如何接收信号：
1. 把接收到的信号放入信号队列中；
2. 执行中的进程会在特定时刻（如从系统空间返回到用户空间之前）检查并处理自己的信号队列

### 管道
管道就是基于生产者/消费者模型来实现通信的，最基本的管道通信由一端的读进程，管道，还有另一端的写进程构成，通信的介质时共享文件，也称管道文件。

### 命名管道FIFO
命名管道可用于任何有访问权的进程，通过文件名将其打开和进行读写。Pipe和FIFO除了建立、打开、删除的方式不同外，二者几乎一模一样
FIFO的实现：通过mkfifo()函数建立命名管道。命名管道实质上也是通过内核缓冲区来实现数据传输。建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，由访问权限 进程，可以通过磁盘的索引节点来读写这块缓冲区。当不再被任何进程使用时，命名管道在内存中释放，但磁盘节点仍然存在。

### 信号量
当多个进程同时访问某个资源的时候，通过信号量来控制对共享资源的访问

### 共享内存
共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件，因此，共享内存通常和其他进程间通信方式一起使用。
优点：
+ 访问共享内存区域和访问进程独有的内存区域一样快，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据过多复制
+ 比如管道和消息队列，需要在内核和用户空间进行四次的数据拷贝（读输入文件、写到管道；读管道、写到输出文件），而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存输入到文件。
+ 消息队列的实现需要系统调用，也就经常需要用户态和内核态的互相转换；而共享内存只在建立时需要系统调用，之后所有的访问都可作为常规内存访问，无需借助内核
缺点：存在并发问题，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用
实现：mmap()不是专门用来共享内存的，mmap()系统调用的主要作用时将普通文件映射到进程的地址空间，然后可以像访问普遍内存一样对文件进行访问，不必再调用read()，write()等操作。因此多个进程可以通过mmap()映射同一个普通文件，来实现共享内存。

### 消息队列
消息队列是消息组成的链表，保存在内核中。消息队列中的消息是一个具有特定格式的数据块。操作系统中可以存在多个消息队列，每个消息队列有唯一的key进行标识。
优缺点：和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据。消息队列允许一个或多个进程向它写入与读取消息，消息队列是异步的
实现：操作系统提供创建消息队列、取消息、发消息等系统调用。操作系统负责读写同步；若消息队列已满，则写消息进程排队等待；若取消息进程没有找到需要的信息，则在消息队列中轮询。

## 协程
协程是一个用户态的线程，用户在堆上模拟出协程的栈空间。当需要进行协程上下文切换时，主线程只需要交换栈空间和恢复协程的一些相关的寄存器的状态，就可以实现上下文切换。没有了从用户态转换到内核态的切换成本，协程的执行也就更加高效
和传统的线程不同的是：线程是抢占式执行，当发生系统调用或中断时，交给OS调度执行；而协程通过yield主动让出cpu所有权，切换到其他协程执行。

## 操作系统是如何做到上下文切换的？
当一个正在运行中的进程被中断，操作系统指定另一个就绪态的进程进入运行态，这个过程就是进程切换，也叫上下文切换。
1. 保持处理器上下文环境：将CPU程序计数器和寄存器的值保存到当前进程的私有堆栈里。
2. 更新当前进程的PCB（包括状态更改）
3. 将当前进程移到就绪队列或者阻塞队列
4. 根据调度算法，选择就绪队列中一个合适的新进程，将其更改为运行态
5. 更新内存管理的数据结构
6. 新进程内对堆栈所保存的上下文信息载入到CPU的寄存器和程序计数器，占有CPU。

## 线程的实现
线程的实现方式主要有三种：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现
+ 内核线程实现（KLT, Kernel-Level Thread），直接由操作系统内核支持的线程
	+ 内核线程建立和销毁都是在内核的支持下运行，由操作系统负责管理，通过系统调用完成的。线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成的。
	+ 内核线程驻留在内核空间，它们时内核对象。操作系统调度器管理、调度并分派这些线程。运行时库位每个用户级线程请求一个内核级线程，将用户线程映射或绑定到上面。用户线程在其声明期内都会绑定到该内核线程。一旦用户线程终止，两个线程都将离开系统。这被称作“一对一”线程映射。内核空间内为每一个内核支持线程设置了一个线程控制块（TCB），内核根据该控制块，感知线程的存在，并进行控制。
	+ 特点：
		+ 当某个线程希望建立一个新线程或撤销一个已有线程时，它进行一个系统调用。
		+ 多处理器系统中，内核能够并行执行同一进程内的多个线程
		+ 如果进程中的一个线程被阻塞，能够切换同一进程内的其他线程继续执行
		+ 所有能够阻塞线程的调用都以系统调用的形式实现，代价较大
+ 用户线程实现
	+ 狭义上将，用户线程指完全建立在用户空间的线程库上。这种线程不需要切换内核态，效率非常高且低消耗。
	+ 优点：
		+ 可以在不支持线程的操作系统上实现
		+ 创建和销毁线程、线程切换代价等线程管理的代价比内核线程少，因为保存线程状态的过程和调用程序都只是本进程空间的操作
		+ 运行每个进程定制自己的调度算法，线程管理比较灵活
		+ 线程能够利用的表空间和堆栈空间比内核级线程多
		+ 不需要trap，不需要上下文切换，也不需要对内存高速缓存进行刷新，使得线程调用非常快捷
	+ 缺点
		+ 如果线程发生I/O等阻塞从而引起系统调用时，由于内核不知道多线程的存在，会阻塞整个进程从而阻塞所有线程。
		+ 一个单独的进程内部，没有时钟中断，所以不可能用轮转调度的方式调度线程
		+ 资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用，因此对于多线程不能被多核系统加速
+ 用户线程加轻量级进程混合实现
	+ 本质是内核线程与用户线程混合使用，可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。

### 用户级线程和内核级线程的区别
+ 内核级线程时OS内核可感知的，而用户级线程时OS内核不可感知的
+ 用户级线程的创建、撤销和调度不需要OS内核的支持；而内核级线程创建、撤销和调度都需OS内核提供支持，而且与进程的创建、撤销和调度大体是相同的。
+ 用户级线程执行系统调用指定是导致其所属进程被中断，而内核级线程执行系统调用指令时，只导致该线程被中断
+ 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核级线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序复杂线程的调度
+ 用户级线程的程序实体是运行在用户态下的程序，而内核级线程的程序实体则是可以运行在任何状态下的程序


## 线程之间私有和共享的资源有哪些？
+ 私有资源：线程上下文（栈区、程序计数器、栈指针以及函数运行使用的寄存器）
+ 共享资源：处理线程上下文外的内容（代码区，数据区，堆区，栈区（理论上私有，实际实现是共享的），动态链接库，打开的文件）

## 线程同步的方式
1. 互斥锁：可以保证同一时刻只有一个线程访问共享资源
2. 读写锁：适用于读多写少的场景，可以运行多个线程同时读取共享资源，但是只有一个线程能够写入共享资源
3. 条件变量：用于线程之间的通信，可以让一个线程等待另一个线程满足某个条件之后再继续执行，常和互斥锁一起使用，线程可以在互斥锁上等待条件变量的发生。
4. 信号量：它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目

### 条件变量为什么要配合锁使用？
条件变量的作用是允许线程在某个特定的条件下等待，直到其他线程满足了这个条件并通知等待线程。而互斥锁的作用是为了保证共享资源的互斥访问，即同一时间只有一个线程可以访问这个资源，其他线程需要等待该线程释放锁之后才能访问。
条件变量通常和互斥锁配合使用，这是因为在等待条件的过程总需要对条件变量进行保护，就会出现竞态条件，导致程序出错
具体来说，在等待条件的线程中，通常会先获取互斥锁保护条件变量，然后再检查条件是否满足，如果不满足，则通过条件变量进入等待状态，并释放互斥锁。当条件满足时，通常会通过唤醒等待线程的方式来通知等待线程，并再次获取互斥锁，以确保对条件变量的互斥访问。

## 栈和堆的区别
+ 管理方式不同
	+ 栈有编译器自动管理，无需程序员手工控制；堆：产生和释放由程序员控制
+ 空间大小不同
	+ 栈的空间有限，堆内存可以达到4G
+ 能否产生碎片
	+ 栈不会产生碎片，因为栈是种先进后出的队列。堆则容易产生碎片，多次的new/delete会造成内存的不连续，从而造成大量的碎片
+ 生成方向不同
	+ 堆的生长方式是向上的，栈是向下的
+ 分配方式不同
	+ 堆是动态分配。栈可以是静态分配和动态分配两种，但栈的动态分配由编译器释放


## 进程的分类
### 僵尸进程如何产生的？如何处理僵尸进程？
当一个子进程先于父进程结束时，它将变成一个僵尸进程。具体来说，当子进程完成其任务后，它会发送一个称为“退出状态”的信号给父进程，父进程负责处理这个信号。如果父进程没有及时处理这个信号，那么子进程就会称为一个僵尸进程。
处理僵尸进程的一般方法是让父进程及时处理子进程发来的退出状态信号。这可以通过调用wait()或waitpid()系统调用来实现。这些调用将阻塞父进程，直到子进程发送退出状态信号。
在使用wait()或waitpid()之前，父进程可以使用signal()系统调用来设置一个SIGCHLD信号处理程序。这个处理程序会在子进程结束时自动被调用，并通知父进程。
除了使用系统调用来处理僵尸进程，另一种方法时通过设计父进程来避免僵尸进程的产生。这可以通过让父进程在fork()子进程之后立即调用exec()系统调用来实现。这样，子进程就会变成新的进程，而不是父进程的直接子进程，从而避免了僵尸进程的产生。
### 孤儿进程

### 创建守护进程
1. 在父进程中执行fork并退出父进程，子进程继续。
2. 在子进程中调用setsid函数创建新的会话。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。
3. 在子进程中调用chdir函数，让根目录“/”成为子进程的工作目录。进程活动时，其工作目录所在的文件系统不能卸下，一般需要将工作目录改变到根目录
4. 在子进程中关闭任何不需要的文件描述符。进程从创建它的父进程哪里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误
5. 在子进程中调用umask函数，设置进程的umask为0。进程从创建它的父进程哪里继承了文件创建掩码。它可能会修改守护进程所创建的文件的存取位。为了防止这一点，将文件的创建掩码清除。


# 锁
## 锁的类型
+ 互斥锁：加锁失败时，会有【线程切换】来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗较大
+ 自旋锁：加锁失败时，并不会注定产生线程切换，而是一直忙等待，直到获取到锁。如果被锁住的代码执行时间很短，那么这个忙等待的时间相对应也很短
+ 读写锁
+ 互斥锁、自旋锁、读写锁都属于【悲观锁】，悲观锁认为并发访问共享资源时，冲突改了可能非常高，所以在访问共享资源前，都需要先加锁
+ 如果并发访问资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。但是，一旦冲突概率上升，就不适合使用乐观锁，因为它解决冲突的重试成本很高

## 死锁
死锁是指多个进程循环等待其他进程占有的资源而无限期地僵持下去的局面。当两个或两个以上的进程同时对多个互斥请求使用时，有可能导致死锁

### 造成死锁的必要条件
1. 互斥条件。即某个资源在一段时间内只能由一个进程占有，不能同时被两个或者两个以上的进程占有
2. 不可抢占条件。进程所获得的资源在未使用完毕前，资源申请者不能强行地从资源占有者手中夺取资源，而只能由该资源占有者自行释放
3. 占有且申请条件。进程至少已占有一个资源，但又申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是它在等待新资源的同时，仍继续占有已有资源。
4. 循环等待条件。存在一个进程等待序列{P1,P2,P3...Pn}，其中P1等待P2所占有的某一资源，P2等待P3占有的某一资源...，而Pn等待P1所占有的某一资源，形成一个进程循环等待环

### 死锁预防
死锁预防是保证系统不进入死锁的一种策略，基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的必要条件中的一个或几个，保证系统不进入死锁状态。
1. 打破互斥条件。即允许进程同时访问某些资源
2. 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源，就是说当一个进程已经占有了某些资源，而又申请新的资源，但又不能被立即满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其他进程，这就相当于该进程占有的资源被隐蔽地抢占了。该方法实现困难，会降低系统性能
3. 打破占有且申请条件。可以实行资源预先分配的策略，即进程再【运行前一次性向系统申请它所需要的全部资源】，如果某个进程所需要的全部资源得不到满足，则不分配资源，此进程暂不运行。
4. 打破循环等待条件，实行资源有序分配策略，即把资源事先编号，按号分配。所有进程对资源的请求必须严格按资源序号递增的顺序提出，进程占用了小号资源，才能申请大号资源，就不会产生环路

#### 在数据库层面，有两种设置参数策略通过【打破循环等待条件】来解除死锁状态
+ 设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了
+ 开启主动死锁检测。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行

#### 死锁避免算法：银行家算法
基本思想时分配资源之前，判断系统是否是安全的，若是则分配。即一直当前所有进程对各个资源的需求，以及限制已占有的资源，还有系统可用资源Available
1. 求出每个进程当前还需要多少资源Need
2. 选取Need <= Available的某个进程分配，若无则等待更到资源释放到系统
3. 执行安全性检测算法，若安全则进行分配，否则到第2步找其他进程
4. 回收原进程已有资源和已分配的资源，找其他进程分配