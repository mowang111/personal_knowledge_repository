# MySQL如何实现的索引机制？
MySQL中的索引分为三类：B+树索引、Hash索引、全文索引

## InnoDB索引与MyISAM索引的实现区别？
InnoDB索引的数据和索引是放在一起的，而MyISAM索引文件和数据文件是分离的，使用B+树实现，主键索引和辅助索引实现一致，索引文件仅保存记录所在页的指针（物理地址），通过这些地址来读取页，进而读取被索引的行。

+ InnoDB的辅助索引data域存储相应记录主键的值而不是地址
+ InnoDB的数据文件本身就是主索引文件
+ MyISAM的索引和数据是分开存储的

## 一个表中如果没有创建索引，还会创建B+树吗？
会
选择非空唯一列或者创建隐藏字段作为主键索引


# 说一下B+树索引实现原理（数据结构）

## 聚簇索引与非聚簇索引B+树实现有什么区别？
**聚簇索引**
特点：
+ 聚簇索引的`索引和数据保存在同一个B+树中`
+ `页内的记录`是按照`主键的大小顺序`排成一个`单向链表`
+ `页和页之间`也是根据页中记录的`主键大小顺序`排成一个`双向链表`
+ `非叶子节点`存储的是记录的`主键+页号`
+ `叶子节点`存储的是`完整用户记录`
优点：
+ 数据访问速度快，因为`索引和数据保存在同一个B+树中`，因此从聚簇索引中获取所有数据比非聚簇索引快
+ 聚簇索引对于`主键的排序查找`和`范围查找`速度非常快
+ 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于`数据都是紧密相连的`，数据库可以从更少的数据块中提取数据，节省了大量的IO操作
缺点：
+ `插入速度严重依赖插入顺序`，按照主键的顺序插入是最快的方式，否则会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会`定义一个自增的ID列为主键`。
+ 更新主键的代价很高，因为将导致被更新的行移动，因此，对于InnoDB表，我们一般定义为`主键不可更新`。
限制：
+ 只有InnoDB引擎支持聚簇索引，MyISAM不支持聚簇索引。
+ 由于数据的物理存储排序方式只能有一种，所以每个MySQL表只能有一个聚簇索引。
+ 如果没有为表定义主键，InnoDB会选择非空的唯一索引列代替。如果没有这样的列，InnoDB会隐式的定义一个主键作为聚簇索引。
+ `为了充分利用聚簇索引的聚簇特性，InnoDB中表的主键应选择有序的id, 不建议使用无序的id`, 比如UUID、MD5、HASH、字符串作为主键，`无法保证数据的顺序增长`。
**非聚簇索引(二级索引、辅助索引)**
聚簇索引，只能在搜索条件是主键值时才发挥作用，因为B+树中的数据都是按照主键进行排序的，如果想以别的列作为搜索条件，那么需要创建`非聚簇索引`

非聚簇索引的B+树与聚簇索引的区别：
+ 页内记录是按照非主键列的大小顺序排成的单向链表。
+ 页和页之间也是根据页中记录的非主键列的大小顺序排成的双向链表。
+ 非叶子节点存储的是记录的非主键列+页号。
+ 叶子节点存储的并不是完整的用户记录，而只是非主键列+主键两个列的值。


## 说一下B+树中聚簇索引的查找（匹配）逻辑

## 说一下B+树中非举措索引的查找（匹配）逻辑

## 平衡二叉树，红黑树，B树和B+树的区别是什么？都有哪些应用场景？
平衡二叉树：保证子树的高度差小于等于1

红黑树：
+ hashmap存储
+ 两次旋转达到平衡
+ 分为红黑节点
红黑树的长子树只要不超过短子树的两倍即可

B树和B+树
+ B+树中非叶子节点的关键字也会同时存在子节点中，并且是在子节点所有关键字的最大值（或最小）。
+ B+树中非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而B树中，非叶子节点既保存索引，也保存数据记录
+ B+树中所有关键字都在叶子节点出现，叶子节点构成了一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。

## 一个B+树中大概能存放多少索引记录
page=16KB, 
根节点只存主键+指针（叶子节点）+其他信息 = 10字节
1600个节点
1600×1600×1600

叶子节点存数据比如1k,

三层就是千万级别

## 使用B+树存储的索引crud（创建读取更新删除）执行效率如可

## 什么是自适应哈希索引？

## 什么是2-3树，2-3-4树？

# 为什么建议使用自增长的主键作为索引？（说一下自增主键和字符串类型的主键的区别和影响）
+ 自增主键能够维持底层数据顺序写入
+ 读取可以由B+树的二分查找定位
+ 支持范围查找，范围数据自带顺序

## 使用int自增主键后最大id是10，删除id 10和9，再添加一条记录，最后添加的id是几？删除后重启mysql然后添加一条记录最后id是几？
+ 如果重启，会从最大id开始递增
+ 如果没重启，会延续删除之前的最大id开始递增

# 索引的优缺点？
优点
聚簇（主键）索引：
+ 顺序读写
+ 范围快速查找
+ 范围查找自带顺序
非聚簇索引：
+ 条件查询避免全表扫描
+ 范围，排序，分组查询返回行id，排序分组后，再回表查询完整数据，有可能利用顺序读写
+ 覆盖索引不需要回表操作

索引的代价
在空间和时间上都会有消耗：
+ 空间
每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。
+ 时间
每次对表中的数据进行增删改操作时，都需要去修改各个B+树索引，而增删改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位、页面分裂、页面回收等操作来维护号节点和记录的排序，如果建立了很多索引，每个索引对应的B+树都要进行相关的维护操作。

## 使用索引一定能提升效率吗
+ 索引建立太多
+ 增删改操作慢
+ 唯一索引约束时

## 如果是大段文本内容，如何创建（优化）索引？
+ 分表存储，然后创建索引
+ 使用es为大文本创建索引（Elasticsearch 是一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎）

# 什么是聚簇索引
主键索引，索引和数据放在一起组成一个B+树

## 一个表中可以有多个聚簇索引吗？
不可以

## 聚簇索引和非聚簇索引特点是什么？


## CRUD时聚簇索引与非聚簇索引的区别是什么？
+ 聚簇索引插入新值比采用非聚簇索引插入新值要慢很多，因为插入要保证主键不能重复。
+ 聚簇索引范围、排序查找效率高，因为是有序的
+ 非聚簇索引访问时需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

## 非聚簇索引为什么不存数据地址值而存储主键？
因为聚簇索引中有时会引发分页操作、重排操作，数据地址可能会有移动
