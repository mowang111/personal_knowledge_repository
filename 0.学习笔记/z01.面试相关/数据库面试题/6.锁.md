为了保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证。锁冲突也是影响数据库并发访问性能的一个重要因素。

# MySQL并发事务访问相同记录
1. 读-读情况
2. 写-写情况
	脏写
	1. 锁结构
		+ trx信息：锁结构是哪个事务生成的
		+ is_waiting：表示当前事务是否在等待
4. 读-写或写-读情况
在这种情况下可能会发生脏读、不可重复读、幻读的问题

### 并发问题的解决方案
如何解决脏读、不可重复读、幻读这些问题：
+ 方案一：读操作利用多版本并发控制（MVCC），写操作进行加锁
	+ MVCC，就是生成一个ReadView，通过ReadView找到符合条件的记录版本（历史版本由undo日志构建）。查询语句只能读到在生成Readview之前已提交事务所做的更改，在生成ReadView之前未提交的事务或者之后再开启的事务所作的更改时看不到的。而写操作肯定是针对最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突
	+ 普通的SELECT语句在READ COMMITTED和REPEATALE READ隔离级别下会使用到MVCC读取记录
		+ 在READ COMMITTED隔离级别下，一个事务在执行过程中每次执行SELECT操作时都会生成一个ReadView，ReadView的存在本身就保证了事务不可以读到未提交的事务所作的更改，也就避免了脏读的现象
		+ 在REPEATABLE READ隔离级别下，一个事务在执行过程中只有第一次执行SELECT操作才会生成一个ReadView，之后的SELECT操作都复用这个ReadView，这样就比避免了不可重复读和幻读的问题
+ 方案二：读和写操作都用加锁
	+ 显然可以解决脏读和不可重复读的问题
	+ 幻读的问题的产生是因为当前事务读取了一个范围的记录，然后另外的事务向该范围内插入了新记录，当前事务再次读取该范围的记录时发现了新插入的新记录，采用加锁的方式解决幻读的问题就有点麻烦，因为当前事务在第一次读取记录的时候幻影记录并不存在，所以读取时不知道怎么加锁。
+ 对比
	+ 采用MVCC方式的话，读-写操作并不冲突，性能更高
	+ 采用加锁方式的话，读-写操作彼此需要排队执行，影响性能

# 锁的不同角度分类
+ 对数据的操作类型划分
	+ 读锁/共享锁（Shared Lock, S lock）
	+ 写锁/排他锁（Exclusive Lock, X Lock）
+ 锁粒度角度划分
	+ 表级锁（不依赖于存储引擎，开销小，避免死锁，但是并发率低）
		+ 表级别的S锁、X锁
		+ 意向锁（intention lock）
			+ InnoDB支持多粒度锁（multiple granularity locking），它允许行级锁和表级锁共存，而意向锁就是其中的一种表锁
				+ 意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁共存
				+ 意向锁是一种不予行级锁冲突的表级锁，这点非常重要
				+ 表明“某个事务正在某些行持有了锁或该事务准备去持有锁”
			+ 意向锁分为两种：
				+ 意向共享锁（intention shared lock, IS）
				+ 意向排他锁（intention exclusive lock, IX）
		+ 自增锁（AUTO-INC锁）
		+ 元数据锁（MDL锁）
			+ MySQL5.5引入了meta data lock，简称MDL锁，属于表级锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果和表结构对不上。
			+ 因此，当对一个表做增删改查操作时，加MDL读锁；当要对表做结构变更操作时，加MDL写锁。
	+ 页级锁
	+ 行级锁
	+ ![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230225163302.png)
		+ 记录锁（Record Locks）
			+ 仅仅把一条记录锁上，官方的类型名称是：LOCK_REC_NOT_GAP;
		+ 间隙锁（Gap locks）
			+ 图中id值为8的记录加了gap锁，意味着不允许别的事务在id值为8的记录前面的间隙插入新记录。
			+ gap锁的提出仅仅是为了防止插入幻影记录而提出的。
			+ 间隙锁可能导致死锁
		+ 临键锁（Next-Key Locks）
			+ 记录锁和间隙锁的合体
		+ 插入意向锁（Insert Intention Key）
			+ InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。
			+ InnoDB就把这种类型的锁命名为Insert Intention Locks，官方的类型名称为：LOCK_INSERT_INTENTION，称之为插入意向锁。
			+ 插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生
+ 对待锁的态度划分
	+ 悲观锁
		+ select .... for update是MySQL中的悲观锁，其在执行过程中，所有扫描行都会被锁上，因此在MySQL中用悲观锁必须确定使用了索引，而不是全表扫描，否则会把整个表都锁住
	+ 乐观锁
		+ 乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过程序来实现。
		+ 采用版本号机制或者CAS机制实现。
			+ 版本号机制
			+ 时间戳机制
	+ 两种锁的使用场景
		+ 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点就在于程序实现，不存在死锁问题，不过使用场景也会相对乐观，因为它阻止不了除程序以外的数据库操作
		+ 悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面组织其他事务对该数据的操作权限，防止读-写和写-写的冲突
+ 加锁方式
	+ 隐式锁
		+ 一般情况下，新插入一条记录并不加锁，通过一种称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。
	+ 显示锁
+ 其他
	+ 全局锁
	+ 死锁
		+ 解决方案
			+ 等待，直到超时
			+ 死锁检测
				+ wait-for graph算法
				+ 一旦检测到死锁，选择回滚undo量最小的的事务
			+ 如何避免死锁
				+ 合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争
				+ 调整业务逻辑SQL执行顺序，避免update/delete长时间持有锁的SQL在事务前面
				+ 避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的事件，发生锁冲突的几率也更小。
				+ 在并发比较高的系统中，不要显式加锁，特别是在事务里加锁。如select ... for update语句，如果是在事务里面运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录
				+ 降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免很多因为gap锁造成的死锁。


# 锁的内存结构
如果符合下面这些条件的记录就会放到一个锁结构中。
+ 在同一个事务中进行加锁操作
+ 被加锁的记录在同一个页面中
+ 加锁的类型是一样的
+ 等待状态是一样的

InnoDB存储引擎中的锁结构如下：
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230225204558.png)

# 锁监控
