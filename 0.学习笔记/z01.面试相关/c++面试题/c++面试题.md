# C++基础

## 预处理、编译、汇编、链接（cpp是如何运行起来的）
预处理阶段：预处理根据#开头的命令，修改原始的程序，如把头文件插入到程序文本中，删除所有注释等。
编译阶段：编译过程就是把预处理完的文件进行一些了的词法分析、语法分析、语义分析等，最终产生相应的**汇编语言文件**，不同的高级语言翻译的汇编语言相同。编译是对源文件分别进行的，每个源文件都产生一个目标文件。
汇编阶段：把汇编语言翻译成目标机器指令
链接阶段：将有关的目标文件和库文件相连接，使得所有的这些文件能够被操作系统装入执行的统一整体。链接处理分为两种：
+ 静态链接：静态链接时把要调用的函数或者过程连接到可执行文件中，称为可执行文件中的一部分。
+ 动态链接：函数的代码被放到称作是动态链接或共享对象的某个目标文件中。链接程序要做的只是在最终的可执行文件中记录下相对应的信息。在可执行文件被执行时，根据可执行程序中记录的信息，将动态链接库的全部内容映射到相应运行程序的虚拟地址空间上。
运行：最后，操作系统会加载可执行文件到内存中，并执行其中的代码。程序运行时会分配内存，执行指令，读写文件等操作，直到程序退出。

## C语言和C++有什么区别？
+ C是面向过程的，C++是面向对象的。因此C++中有类和对象、继承和多态这样OOP语言必备的内容，此外C++还支持模板，运算符重载以及STL;
+ 在输入输出方式上，C是scanf/printf库函数，C++是cin/cout，即istream和ostream类型的对象
+ 在动态内存管理上，C是通过malloc/free来进行堆内存的分配和释放的，而C++是通过new/delete来管理堆内存的
+ 在强制类型转换上，C的强制类型转换使用小括号里面加类型进行强转，而C++可以使用static_cast, reinterpret_cast, dynamic_cast 和 const_cast继续强转
+ 在C++中，struct关键字不仅可以用来定义结构体，也可以用来定义类
+ C++不仅支持指针，还支持更安全的引用。
+ C++支持自定义命名空间，而C不支持

## c++中struct和class有什么区别？
+ 默认继承、成员访问权限不一样
+ 是否支持类模板
## extern "C"的作用

## c++中指针和引用有什么区别？
+ 指针和引用都是一种内存地址的概念，但是指针是一个实体，可以声明为void；引用知识一个别名，不能为void;
+ 引用内部其实是一个指针，引用比指针更安全；相对的，引用没有指针灵活；
+ 引用和指针都可以作为参数传递给函数，用户更改函数作用域外的变量，在传递大对象时避免复制，提升效率。作为参数也有不同，传递指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递变量的地址。
+ 指针可以有多级指向，但是引用只能有一级引用。
+ 引用时一块内存的别名，在添加到符号表时，是将”引用变量名-引用对象的地址“添加到符号表中，符号表一经完成不能改变，所以引用只能在定义时被绑定到一块内存上，后续不能更改引用对象。指针指向一块内存，其值是所指向的内存的地址，在编译的时候，则是将”指针变量名-指针变量的地址“添加到符号表中，所以指针包含的内容是可以改变的，允许拷贝和赋值。

## 数组和指针的区别
+ 数组存放的是数据，是直接访问数据的；指针存放的是变量的地址，是间接访问数据的。
+ 数组通常存储在静态存储区或栈上；指针可以随时地指向任意类型的内存块。
+ 用运算符sizeof可以计算出数组的容量（字节数）；sizeof(p)得到的是一个指针变量p的字节数，而不是p指针所指向的内存容量。
+ `char a[] = "hello"`数组指向每个数组元素；`char *p = "hello"` 而p指向字符串首地址。

## 迭代器、指针区别
迭代器：用于提供一种方法顺序访问一个聚合对象中的各个元素，而又无需暴露该对象的内部表示。
迭代器和指针区别：迭代器不是指针，是类模板，表现的像指针，其本质是封装了原生指针，提供了比指针更高级的行为，相当于一种智能指针，可以根据不同类型的数据结构来实现递增、递减操作。迭代器返回的是对象引用而不是对象的值。

## strcpy 和 memcpy区别
+ 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。
+ 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符串的结束符`\0`才结束，所以容易溢出。memcpy则是根据第3个参数决定复制的长度
+ 用途不同。通常复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。

## 哪些函数不能是虚函数
+ 构造函数
+ 内联函数：内联函数在编译阶段进行函数体的替换操作，而虚函数在运行期间进行时确定，所以不能是虚函数
+ 静态函数：不属于对象属于类，静态成员函数没有this指针，设置为虚函数没有意义
+ 友元函数、普通函数：不属于类的成员函数，不能被继承

## 构造函数为什么不能定义为虚函数，析构函数为什么定义为虚函数？
+ 先构造函数，再初始化虚函数表，如果构造函数为虚函数，当创建对象时，就需要去找虚函数表，但是此时虚函数表还没有初始化
+ 析构函数定义为虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将析构函数定义为虚函数，只会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏
+ 我们将析构函数定义为虚函数，在执行析构时，则根据对象的类型来执行析构函数，此时派生类的资源得到释放。

## 谈一谈多态的理解
通过父类的指针指向子类的对象，达到重写函数的目的

**一句话定义**：多态就是一个函数多种形态，比较常见的就是函数重载和函数重写，也就是函数静态多态和动态多态。
下面我分开说说我对多态的理解：
函数重载也叫编译时多态，就是在同一个作用域下有相同的函数名，不同的函数签名（比如函数参数列表不同等）的函数。如果没有函数重载，很多功能相似但是不完全相同的函数就要取很多不同的名字，比如double和int等等不同类型的参数对应的加法函数就不相同，就要实现很多不同名称的函数，函数重载使得代码编写更加合理。然后cpp函数重载底层汇编代码实现其实还是对这些不同函数命了不同的名称，每个函数对应不同的函数签名，而c语言反汇编之后的代码时没有这样的处理的，所以c语言不支持重载。
另一种就是函数重写，是指在派生类中覆盖基类中的同名函数，也叫函数覆盖，要求基类函数必须是虚函数，我也研究过函数重写的原理，基类中如果有虚函数，编译器会自动为每个含有虚函数的类生成一份虚表，可以理解为一个一维数组，虚表里面保存了虚函数的入口地址，编译的时候会在每个对象的前四个或八个字节中保存一个虚表指针，这个虚表指针指向对象所属类的虚表，在构造的时候，根据对象的类型初始化虚表指针，从而让虚表指针指向正确的虚表，在调用虚函数的时候能找到正确的函数，这个虚表在运行是不能被修改，且全局可见，所以不是放在堆区，栈区，也不是放在代码区，全局区，而是放在常量区。
以上就是我对多态的理解

## 对虚函数机制的理解，单继承、多继承、虚继承条件下虚函数表的结构
c++的虚函数是通过虚函数表来实现的，表中主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题。
多重继承会有多个虚函数表，几重继承就会有几个虚函数表，这些表按照派生的顺序依次排列，如果子类改写了父类的虚函数，那么就会用子类自己的虚函数覆盖虚函数表的相应位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾

## 如果虚函数是有效的，那为什么不把所有函数设为虚函数？
1. 有的函数不能也不需要定义为虚函数，例如构造函数就没必要多态和定义为虚函数
2. 有的类不能被继承，因此没必要把它的函数定义为虚函数，例如定义为class A final的类A
3. 虚函数的时间和空间开销更大，有虚函数入口地址表以及指向该表首的指针，虚函数比非虚函数的调用略慢



## 什么场景需要用到纯虚函数？纯虚函数的作用是什么？
纯虚函数在基类中是没有定义的，必须在子类中加以实现，例如动物可用作为一个基类派生出老虎，狮子等，但是动物本身生成一个对象并不合理。

## RAII 机制
RAII是Resource Acquistion Is Initialization(资源获取就是初始化)，是C++语言的一种管理资源、避免泄漏的惯用法。利用C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命周期内控制对资源的访问，使之始终保持有效，最后在对象析构时，释放构造时获取的资源。
如果把资源用类进行封装，对资源操作都封装在类的内部，在析构函数中释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动被调用，如此，就不用程序员显示的去调用释放资源的操作了。

## 类的大小怎么计算？
类的大小需要考虑一下内容：
+ 非静态成员变量大小
	+ 32位系统中，`int`和`float`占4个字节
	+ 静态成员变量存放在静态存储区，不会影响实例大小
+ 数据对齐到多少位
+ 虚函数

## volatile关键字的作用
+ 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。保证对特殊地址的稳定访问。
+ 在多线程中，当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用时防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的的变量，这样就会导致程序错误执行。


## 在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？

   1. 在创建构造函数时的调用顺序：
      1. 调用父类的构造函数；
      2. 调用成员变量的构造函数；
      3. 调用类自身的构造函数
   
   2. 析构函数的调用顺序：
   
      1. 调用自身的析构函数
      2. 调用成员变量的析构函数
      3. 调用父类的析构函数

## 谈一谈static关键字在c语言和c++中的区别
在C中static用来修饰局部静态变量和全局静态变量、函数。在c++中，除了上述功能外，还用来定义类的成员变量和函数，即静态成员变量和静态成员函数。

另外我谈一谈堆静态变量的理解，静态变量是属于静态存储方式，在静态存储区分配内存单元，该区域中的数据在整个程序的运行期间都不释放，不过，虽然在程序整个执行过程中始终存在，但是在它作用域外不能使用。
另外，静态存储方式的变量不一定都是静态变量，比如全局变量虽然属于静态存储方式，但是不一定是静态变量，必须加static定义之后才会称为静态全局变量。

静态全局变量和非静态全局变量的存储方式虽然都是静态存储，但是，非静态全局变量的作用域是整个源程序，而静态全局变量则限制了其作用域，只在定义该变量的源文件内有效。

## 变量的声明和定义有什么区别
+ 声明是告诉编译器变量或函数的类型或名称等，定义是告诉编译器变量的值、函数具体干嘛
+ 变量的定义为变量分配地址和存储空间，变量的声明不分配地址。
+ 一个变量可以在多个地方声明，但是只能在一个地方定义。

## sizeof和strlen的区别
+ sizeof是一个操作符，strlen是库函数
+ sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\\0'的字符串作参数
+ 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来，并且sizeof计算的时数据类型占内存的大小，而strlen计算的时字符串实际的长度。
+ 数组做sizeof的参数不退化，传递给strlen就退化为指针（4个字节）了

## volatile、extern区别
+ volatile
	+ 数据重新从内存中读取
	+ 告诉编译器，不要对这个变量做优化，保证其顺序性
+ extern
	+ 用在变量或函数的声明前，说明此变量/函数在别处定义的，要在此处引用
	+ 在C++中调用C库函数，需要在C++程序总用extern ”C“声明要引用的函数，告诉链接器在链接的时候用C语言规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同，以此来解决名字匹配的问题。

## 谈一谈c和c++中的内存管理
程序内存空间（栈区，堆区，全局/静态数据区，常量区，代码区）
	1. 栈区：由编译器自动分配释放，存放为函数运行的局部变量，函数参数，返回数据，返回地址等。
	2. 堆区：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收
	3. 全局数据区：也叫静态区，存放全局变量，静态数据。程序结束后由系统释放。
	4. 常量区：存放常量字符串等，其值不可变。
	5. 代码区：存放函数体的二进制代码。

c/c++内存分配的三种方式：
+ 从静态存储区分配。内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量
+ 从栈上分配。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。分配的内存容量有限。
+ 从堆上分配。也叫做动态内存分配，程序运行时用malloc或者new申请任意大小的内存，程序员自己负责在何时用free或者delete释放内存。

## c语言的结构体和C++的类有什么区别
+ C语言的结构体不能有函数成员，而C++的类可以有
+ C语言的结构体中数据成员时没有private、public和protected访问限定的，而C++的类的成员有这些访问限定
+ C语言的结构体没有继承关系，而C++的类有丰富的继承关系

## new/delete与malloc/free的区别是什么
+ new能自动计算需要分配的内存空间，而malloc需要手工计算字节数
+ new与delete直接带具体类型的指针，malloc和free返回void类型的指针
+ new一般分为两步：new操作和构造。new操作对应于malloc，但new操作可以重载，可以自定义内存分配的策略，不做内存分配，甚至分配到非内存设备上，而malloc不行。
+ new调用构造函数，malloc不能；delete调用析构函数，而free不能。

## 如果new操作的时候内存不够用了，操作系统会做什么操作？
当应用程序请求使用‘new’运算符分配内存时，操作系统会分配一块内存并返回一个指向该内存的指针。如果操作系统没有足够的可用内存来满足请求，那么‘new’运算符会抛出一个‘std::bad_alloc’异常。
操作系统通常会通过以下方式来尝试解决内存不足的问题：
1. 释放闲置内存：操作系统会检查系统中闲置的内存块，并尝试将这些内存块分配给需要内存的应用程序。
2. 从其他应用程序中获取内存：如果操作系统中没有闲置的内存块，则操作系统可能会尝试从其他应用程序中获取内存并将其分配给需要内存的应用程序。
3. 使用虚拟内存技术：操作系统可以使用虚拟内存技术将部分不常用的内存块暂时写入硬盘，以腾出物理内存供需要内存的应用程序使用。
4. 增加物理内存：如果以上方法都无法解决内存不足的问题，操作系统可能会提示用户增加物理内存或者关闭一些程序以释放内存。

### malloc申请内存的方式
1. 通过brk()系统调用从堆分配内存：如果用户分配的内存小于128KB，就是通过brk()函数将【堆顶】指针向高地址移动，获得新的内存空间。free释放内存的时候，并不会吧内存归还给操作系统，而是缓存在malloc的内存池中，待下次使用
2. 通过mmap()的系统调用在文件映射区域分配内存。free释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。
> malloc的实现方案
> 1）malloc函数的实质是它有一个可用的内存块连接为一个长长的链表，即空闲链表
> 2）调用malloc()函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。
> 3）调用free函数时，她将用户释放的内存块连接到空闲链表上。
> 4）到最后，空闲链表会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链表上可能没有可用满足用户要求的片段了。于是，malloc()函数请求延时，并开始在空闲链表上检查各内存片段，对他们进行内存整理，将相邻的小空闲块合并成较大的内存块

### malloc()分配的是物理内存吗？
不是的，malloc()分配的是虚拟内存。如果分配后的虚拟内存没有被访问的话，是不会将虚拟内存映射到物理内存，这样就不会占用物理内存了。只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的也没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

### malloc申请的存储空间能用delete释放吗？
不能，malloc/free主要是为了兼容C, new和delete完全可以取代malloc/free的
+ malloc/free的操作对象都是必须明确大小的，而且不能用在动态类上
+ new和delete会自动进行类型和大小检查，malloc/free不能执行执行构造函数与析构函数，所以动态对象它不行
+ 理论上来说malloc申请的内存可以通过delete释放，但是一般不这样写。

### new[]和delete[]一定要配对使用吗？
new表达式：
+ new表达式调用一个名为operator new（或operator new[]）的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或者对象数组）
+ 编译器运行相应的构造函数以构造这些对象，并为其传入初始值
+ 对象被分配了内存空间并完成构造，返回一个该对象的指针
delete表达式：
+ 对所指向的对象（或对象数组中的元素）执行相应的析构函数
+ 编译器调用名为operator delete（或operator delete[]）的标准库函数释放内存空间
new[]和delete配对使用：delete不同于delete[],它任务这只是一个对象占用的空间，不是对象数组，不会访问前4个字节获取长度，所以只调用一次析构函数，而且最后释放内存的时候只释放了其实地址为A的内存。然而这不是一整块内存的其实地址，整块内存的起始地址应该时A-4,释放内存如果不从内存起始地址操作就会出现段错误。
new和delete[]配对使用：会调用不定次数的析构函数，并且挂掉，因为new的时候没有多申请4个字节存储长度，而delete[]的时候还会向前找4个字节获取长度，这4个字节是未定义的，且释放内存时也释放了起始地址为A-4的内存，而正常起始地址应该为A.

## 构造函数、析构函数、拷贝构造函数等函数的作用
+ 构造函数：
	构造函数在创建一个对象时，系统自动调用。如果用户没有定义构造函数，系统会调用默认构造函数，默认构造函数会将所用的数据成员初始化位0或者空
	构造函数是没有返回值的
+ 析构函数：
	析构函数没有返回值，也没有参数。一个类中只能定义一个析构函数，如果没有，系统会自动调用默认析构函数。
	析构函数调用条件：
	1）在一个函数中定义一个对象，当函数调用结束，则会自动调用析构函数来删除在这个函数体内创建的对象。包括主函数
	2）用new运算符动态构建的对象，在使用delete运算符释放它时
+ 拷贝构造函数：
	+ 拷贝构造函数实际上也是构造函数，具有一般构造函数的所有特性，其名字也与所属类名相同。拷贝构造函数中只有一个参数，这个参数时是某个同类对象的引用。
	+ 拷贝构造函数的目的是用一个已有的对象创建一个新的对象。
	+ 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数（浅拷贝），它能够完成成员的意义复制。当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针指向同一地址，当对象快要结束时，会调用两次析构函数。【当数据成员有指针时，必须要深拷贝才安全】
	+ 有三种情况会需要拷贝构造函数
		+ 一个对象以值传递的方式传入函数体，需要拷贝构造函数创建一个临时对象压入到栈空间
		+ 一个对象以值的方式返回，需要拷贝构造函数创建一个临时对象作为返回值
		+ 一个对象需要通过另一个对象进行初始化
	+ 为什么拷贝构造函数必须是引用传递？
		+ 防止递归调用。当一个对象需要以值方式传递时，编译器会生成代码调用它的拷贝构造函数生成一个副本，如果该类的拷贝构造函数的参数不是引用传递，而是值传递，那么就需要创建传递给拷贝构造函数参数的临时对象，而有一次调用该类的拷贝构造函数，无限递归


## 重载、重写以及重定义的区别
+ 重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不同，发生在同一个作用域。
+ 重写：也叫覆盖（override）,一般发生在子类和父类继承关系之间。子类重写父类中有相同名称和参数的虚函数。
+ 重定义：子类重新定义父类中有相同名称的非虚函数（参数列表可以不同），派生类的函数屏蔽了与其同名的基类函数。如果一个派生类，存在重定义的函数，那么，这个类将会隐藏其父类的方法，除非在调用的时候，强制转换为父类类型，才能调用到父类方法。否则试图对子类和父类做类似重载的调用是不能成功的



## c++中的四种类型转换
+ static_cast（静态类型转换）
	+ 静态类型转换，编译时c++编译器会做类型检查，基本类型能转换但是不能转换指针类型。
+ reinterpreter_cast（重新解释类型转换）
	+ static_cast对于基本类型可以转换，但是不能转换指针类型
	+ 若不同类型之间，进行强制类型转换，用reinterpret_cast进行重新解释
+ dynamic_cast（动态类型转换）
	+ c++中重要的，安全的基类和子类之间转换，运行时类型检查
	+ dynamic_cast可以将一个基类对象指针（或引用）转换到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理。
+ const_cast（常量类型转换）
	+ 去除变量的只读属性
	+ const_cast 是用来移除变量的const或volatile限定符。