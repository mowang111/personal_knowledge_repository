1. c++内存管理[[c++面试题#谈一谈c和c++中的内存管理]]
		1.堆区、栈区、全局数据区、常量区、代码区
2. STL常用的容器[[stl相关#STL中常见容器的实现原理]]
	1. 序列性容器
	2. 关联性容器
3. C++11常用特性
	1. 智能指针[##智能指针]
4. 设计模式
	1. 单例模式
	2. 工厂模式
5. select, poll, epoll底层实现原理
	1. select的底层实现基于轮询的。当进程调用select函数时，内核会遍历所有的fd，检查是否有fd就绪，如果有就返回。这种实现方式需要遍历所有的fd，随着fd的增多，遍历时间也会增加，所以select模型适用于fd数量比较小的情况。
		1. select采用基于位图的数据结构来存储文件描述符，每个位表示一个文件描述符的状态，而位图的大小时固定的。
		2. 连接数有限制，处理的最大连接数不超过1024。如果处理超过1024个连接数，则需要修改FD_SETSIZE宏，重新编译
	2. poll是一种改进的I/O多路复用模型，它的底层实现原理是基于轮询的。
		1. 因为poll时基于链表存储，poll没有最大文件描述符数量的限制
	3. epoll是基于事件驱动的，当进程调用epoll函数时，内核会将需要监控的fd添加到一棵红黑树中，并通过回调函数的方式通知进程哪些fd已经就绪。在内核中，通过使用事件缓存区，epoll可以避免不必要的内存拷贝，所以epoll模型适用于fd数量非常多的情况。
		1. epoll使用mmap加速内核与用户空间的消息传递，为了避免不不要的内存拷贝，epoll通过内核与用户空间mmap同一块内存实现。
		2. epoll的两种工作模式
			1. LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不做任何操作，内核还是会继续通知你。
			2. ET(edge triggered)是高速工作方式，只支持no-block socket。在这种该模式下，当描述符从未就绪变为就绪状态，内核就通过epoll告诉你，然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再是就绪状态。
6. TCP三次握手，四次挥手
7. 排序算法分类，时空复杂度，稳定性
8. 多线程
9. 介绍几种IO模型
Unix中有五种I/O模型
+ 阻塞式I/O
+ 非阻塞式I/O
+ I/O复用
+ 信号驱动I/O
+ 异步I/O