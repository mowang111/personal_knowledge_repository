# TCP基本认识
## TCP头格式有哪些？
+ 源端口号和目标端口号
+ 序列号（32bit）：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小，**用来解决网络包乱序的问题**。
+ 确认应答号（32bit）：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号一起的数据都已经被正常接收，**用来解决丢包的问题**。
+ 控制位
	+ ACK
	+ RST
	+ SYN
	+ FIN
+ 窗口大小、校验和、紧急指针

## TCP为什么是面向连接的？
1. 发送之前需要先建立连接（三次握手）
2. 使用排序和确认机制（分组之间并不是独立的；记录了分组之间的状态信息）
3. 具有流量控制和拥塞控制
4. 发送完毕后要释放连接（四次挥手）

## TCP如何保证可靠传输？
1. 三次握手：确认通信实体的存在
2. 序列号：解决乱序问题
3. 确认号/超时重传机制：解决丢包问题
4. 数据校验（校验和）：保证传输数据的正确性

## 有一个IP的服务器监听一个端口，它的TCP的最大连接数是多少？
最大TCP连接数 = 客户端的IP数 ✖ 客户端的端口数
对于IPv4，客户端的IP数最多为2^32，客户端的端口数最多为2^16
当然还受其他因素的影响：
+ 文件描述符：每个TCP连接都是一个文件。Linux对可打开的文件描述符做了三方面的限制。
	+ 系统级：当前系统可打开的最大数量，通过`cat /proc/sys/fs/file-max`查看
	+ 用户级：指定用户可打开的最大数量，通过 `cat /etc/security/limits.conf`查看
	+ 进程级：单个进程可打开的最大数量，通过`cat /proc/sys/fs/nr_open`查看
+ 内存限制

# 为什么需要TCP协议？TCP工作在哪一层？
IP层时不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

如果需要保证网络数据包的可靠性，就需要上层传输层的TCP协议来负责
因为TCP是工作在传输层的可靠数据传输的服务，它能保证接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

# TCP连接和断开
## TCP 三次握手和四次挥手过程
三次握手
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230124232346.png)
TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接时通过三次握手来进行的，其过程如下：
+ 一开始，客户端和服务器都处于`CLOSE`状态。先是服务端主动监听某个端口，处于`LISTEN`状态
+ 客户端会随机初始化序号（`client_isn`），将此序号置于TCP首部的序号字段中，同时把`SYN`标志位置设为1，表示`SYN`报文，然后把第一个`SYN`报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于`SYN-SENT`状态。
+ 服务端收到客户端的`SYN`报文后，首先服务端也随机初始化自己的序号（`server_isn`）,将此序号填入TCP首部的序号字段，其次把TCP首部的确认应答号字段填入`client_isn + 1`, 接着把`SYN`和`ACK`标志位置设为1，最后把报文发给客户端，该报文也不包含应用层数据，之后服务端处于`SYN-RCVD`状态。
+ 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部`ACK`标志位置设为1，其次确认应答号字段填入`server_isn + 1`，最后把报文发送给服务端，这次报文可以写道客户到服务端的数据，之后客户端处于`ESTABLISHED`状态。
+ 服务端收到客户端的应答报文后，也进入`ESTABLISHED`状态

四次挥手
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230124232355.png)

TCP断开连接
双方都可以主动断开连接，断开连接后主机中的资源将被释放，四次挥手的过程如下：
+ 客户端打算关闭连接，会发送一个TCP首部`FIN`标志位被置为1的报文，也即`FIN`报文，之后客户端进入`FIN_WAIT_1`状态
+ 服务端收到该报文后，就向客户端发送`ACK`应答报文，接着服务端进入`CLOSE_WAIT`状态
+ 客户端收到服务端的`ACK`应答报文后，之后进入`FIN_WAIT_2`状态
+ 等待服务端处理完数据后，也向客户端发送`FIN`报文，之后服务器进入`LAST_ACK`状态。
+ 客户端收到服务端的`FIN`报文后，回一个`ACK`应答报文，之后进入`TIME_WAIT`状态
+ 服务端收到了`ACK`应答报文后，就进入了`CLOSE`状态，至此服务端已经完成连接的关闭
+ 客户端在经过`2MSL`一段时间后，自动进入`CLOSE`状态，至此客户端也完成了连接的关闭

主动关闭连接的，才有 TIME_WAIT 状态。

## 为什么是三次握手？不是两次、四次？
+ 三次握手才可以阻止重复历史连接的初始化（主要原因）
	+ 当客户端发送SYN报文后宕机，客户端重启后重新发送一个新的SYN报文，当服务器先收到旧SYN报文，返回SYN+ACK，客户端发现确认号对不上，于是发给服务端RST报文以释放连接，新的SYN+ACK到达后，开始正常完成三次握手
	+ 在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费
+ 三次握手才可以同步双方的初始序列号
	+ TCP协议的通信双方，都必须维护一个【序列号】，序列号是可靠传输的一个关键因素，他的作用：
		+ 接收方可以去除重复的数据
		+ 接收方可以根据数据包的序列号按序接收
		+ 可以标识发送出去的数据包中，哪些是已经被对方收到的(通过ACK报文中的序列号知道)
+ 三次握手才可以避免资源浪费

## 为什么每次建立TCP连接时，初始化的序列号都要求不一样？
+ 主要为了防止历史报文被下一个相同的四元组的连接接收；
+ 为了安全性，防止黑客伪造相同序列号的TCP报文被对方接收。

## 为什么需要四次挥手？
+ TCP是全双工的，关闭连接时，客户端向服务端发送`FIN`时，仅仅表示客户端不再发送数据了但还是能接收数据
+ 服务端收到客户端的`FIN`报文时，先回一个`ACK`应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送`FIN`报文给客户端来表示同意现在关闭连接
从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的`ACK`和`FIN`一般都是分开发送的，因此需要四次挥手。

## 为什么需要TIME_WAIT状态？为什么TIME_WAIT等待时间是2MSL?
MSL:Maximum Segment Lifetime，报文最大生存时间，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

+ 确保ACK报文能够到达服务端，从而使服务端正常关闭连接。
	+ 第四次挥手时，客户端第四次挥手的ACK报文不一定会到达服务端。服务端会超时重传FIN/ACK报文，如果此时客户端已经断开连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到FIN/ACK报文的确认，就无法正常断开连接。MSL时报文段在网络上存活 最长时间，客户端等待2MSL时间，即【客户端ACK报文1MSL超时+服务端FIN报文1MSL传输】,就能够收到服务端重传的FIN/ACK报文，然后客户端重传依次ACK报文，并重新启动2MSL计时器。如此保证服务端能够正常关闭。
+ + 防止历史连接中的数据，被后面相投四元组的连接错误的接收
	+ **序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据**
	+ 2MSL时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
2MSL时长相当于至少运行报文丢失一次

# TCP和UDP的区别
1. 连接
	1. TCP是面向连接的传输层协议，传输数据前先要建立连接
	2. UDP是不需要连接，即刻传输数据
2. 服务对象
	1. TCP是一对一的两点服务，即一条连接只有两个端点
	2. UDP支持一对一、一对多、多对多的交互通信
3. 可靠性
	1. TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达
	2. UDP是尽最大努力交付，不保证可靠交付数据。
4. 拥塞控制、流量控制
	1. TCP有拥塞控制和流量控制机制，保证数据传输的安全性
	2. UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率
5. 首部开销
	1. TCP首部较长，会有一定的开销，首部在没有使用【选项】字段时是20个字节，如果使用了【选项】字段则会变长
	2. UDP首部只有8个字节，并且是固定不变的，开销较小
6. 传输方式
	1. TCP是流式传输，没有边界，但保证顺序和可靠
	2. UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序
7. 分片不同
	1. TCP的数据大小如果大于MSS（最大报文长度）大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片
	2. UDP的数据大小如果大于MTU（最大传输大小）大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据，接着再传给传输层

# 既然IP层会分片，为什么TCP层还需要MSS?
+ MTU：一个网络包的最大长度，以太网中一般为1500字节
+ MSS：出去IP和TCP头部之后，一个网络包中所能容纳的TCP数据的最大长度

如果当一个IP分片丢失，那么整个IP报文的所有分片都得重传。因为IP层本身没有超时重传机制，只能由传输层的TCP负责超时重传，经过TCP层分片后，如果一个TCP分片丢失，进行重发也是以MSS为单位，而不用重传所有的分片。

# TCP流量控制
TCP提供一种机制可以让【发送方】根据【接收方】的实际接收能力控制发送的数据量，这就是所谓的流量控制。
TCP实现流量控制的关键是滑动窗口（Sliding Window）。发送端和接收端均有一个滑动窗口，对应一个缓冲区，记录当前发送或接收到的数据。接收端会在返回的ACK报文中包含自己可用于接收数据的缓冲区大小。
### 滑动窗口
窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值
累计确认或者累计应答
> TCP头里有一个字段叫做`Window`，也就是窗口大小，这个字段时接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来

### 零窗口
如果接收端处理过慢，那么window可能变为0，这种情况下发送端就不再发送数据了。如何在接收端window可用的时候通知发送端呢？TCP使用ZWP(Zero Window Probe，零窗口探针)技术。具体是在发送端引入一个计时器，每当收到一个零窗口的应答后就启动该计时器。每隔一段时间就主动发送报文，由接收端来ACK窗口大小。如果接收者持续返回零窗口（一般是三次），则有的TCP实现会发送RST断开连接。

# TCP重传、拥塞控制
TCP是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的

## 重传机制
### 超时重传
超时重传时间RTO的值应该略大于报文往返RTT的值
### 快速重传
当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文段
### SACK
Selective Acknowledgment 选择性确认
> TCP头部【选项】字段中添加哪些报文已经接收了
### D_SACK
使用SACK告诉发送方有哪些数据被重复接收了
> 应对ACK包丢失的情况

## 拥塞控制
流量控制是避免【发送方】的数据填满【接收方】的缓存，但是并不知道网络中会发生什么。
拥塞控制的目的就是避免【发送方】的数据填满整个网络
拥塞窗口cwnd是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化
> 发生了超时重传，就会认为网络中出现了拥塞
 
下面是拥塞控制的四个主要算法：
### 慢启动
慢启动的算法记住一个规则就行：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。
慢启动门限ssthresh(slow start threshold)
+ 当cwnd < ssthresh时，使用慢启动算法
+ 当cwnd >= ssthresh时，就会使用拥塞避免算法
### 拥塞避免
进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。
变成线性增长
当触发了重传机制，也就进入了【拥塞发生算法】
### 拥塞发生
当发生了「超时重传」，则就会使用拥塞发生算法。
这个时候，ssthresh 和 cwnd 的值会发生变化：
-   `ssthresh` 设为 `cwnd/2`，
-   `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）
当发送了「快速重传」，
TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：
-   `cwnd = cwnd/2` ，也就是设置为原来的一半;
-   `ssthresh = cwnd`;
-   进入快速恢复算法
### 快速恢复
+ 拥塞窗口cwnd=ssthresh +3 (3的意思是有3个数据包被收到了)
+ 重传丢失的数据包
+ 如果再收到重复的ACK，那么cwnd增加1
+ 如果收到新数据的ACK,把cwnd设置为第一步中的ssthresh的值，原因是该ACK确认了新的数据，说明从duplicated ACK时的数据都已收到，该恢复过程已经结束，可以恢复到之前的状态了，也即再次进入拥塞避免状态

>拥塞控制总结：TCP使用拥塞窗口来进行拥塞控制，刚开始为慢启动，拥塞窗口的大小呈指数级增长，当达到慢启动门限的时候，改为拥塞避免，拥塞窗口为线性增长，当触发超时重传，慢启动门限减为一半，重新开始慢启动，当触发快速重传，慢启动门限设置为当前拥塞窗口的一半，拥塞窗口等于慢启动门限，进入拥塞避免


# TCP粘包问题
TCP的数据块时没有边界、没有结构的字节流，因此可能产生粘包；发送方为了将多个发往接收端的包更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据包，合并成一个大的数据包一次性发送。接收方不能及时读取数据，导致缓冲区中的多个包粘连。

解决方法：
1. 发送方关闭Nagle算法
2. 应用层定义消息边界，最常见的两种解决方法时基于长度或者基于终结符
	1. 基于长度的实现有两种方式，一种是使用固定长度；另一种是使用不固定长度，但是需要在应用层协议的协议头中增加表示负载长度的字段，HTTP协议的消息边界就是基于长度实现的；
	2. HTTP协议除了使用基于长度的方式实现边界，也会使用基于终结符的策略，当HTTP使用块传输机制时，HTTP头中旧不再包含Conent-Length了，它会使用负载大小为0的HTTP消息作为终结符表示消息的边界。
3. 基于特定的规则实现消息的边界，例如：使用TCP协议发送JSON数据，接收方可以根据接收到的数据是否能被解析为合法的JSON判断消息是否终结。

### 为什么UDP协议没有粘包问题？
UDP是面向报文的，应用层交给UDP多长的报文，UDP旧照样发送，既不合并，也不拆分，而是保留这些报文的边界。


## TCP Socket交互流程
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230218195023.png)

服务端：创建socket，bind绑定端口号，listen监听，accpet接收用户请求（三次握手后）
客户端：创建socket，connect连接指定计算机（进行三次握手）

完成连接后，服务端和客户端分别在socket中读写信息。
最后关闭socket