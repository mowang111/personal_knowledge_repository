## c++语言生命周期

**编码（Coding）**

**预处理（Pre-processing）**

在这个阶段，发挥作用的是预处理器（Pre-processor）。它的输入是编码阶段产生的源码文件，输出是经过“预处理”的源码文件。“预处理”的目的是文字替换，用到的就是我们熟悉的各种预处理指令，比如 #include、#define、#if 等，实现“**预处理编程**”。

**编译（Compiling）**

在编译阶段，C++ 程序——也就是经过预处理的源码——要经过编译器和链接器的“锤炼”，生成可以在计算机上运行的二进制机器码。这里面的讲究是最多的，也是最复杂的，C++ 编译器要分词、语法解析、生成目标码，并尽可能地去优化。

在编译的过程中，编译器还会根据 C++ 语言规则检查程序的语法、语义是否正确，发现错误就会产生“编译失败”。这就是最基本的 C++“静态检查”。

在处理源码时，由于编译器是依据 C++ 语法检查各种类型、函数的定义，所以，在这个阶段，我们就能够以编译器为目标进行编程，有意识地控制编译器的行为。这里有个新名词，叫“**模板元编程**”。

**运行（Running）**

运行阶段也是我们最熟悉的了。在这个阶段，我们常做的是 GDB 调试、日志追踪、性能分析等，然后收集动态的数据、调整设计思路，再返回编码阶段，重走这个“瀑布模型”，实现“螺旋上升式”的开发。

## c++语言编程范式（Paradigm）

C++ 是一种**多范式**的编程语言。具体来说，现代 C++（11/14 以后）支持“面向过程”“面向对象”“泛型”“模板元”“函数式”这五种主要的编程范式。

![img](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/6ef13308109b2d1795e43c5206c32687.jpg)

**面向过程**是 C++ 里最基本的一种编程范式。它的核心思想是“命令”，通常就是顺序执行的语句、子程序（函数），把任务分解成若干个步骤去执行，最终达成目标。

面向过程体现在 C++ 中，就是源自它的前身——C 语言的那部分，比如变量声明、表达式、分支 / 循环 / 跳转语句，等等。

**面向对象**是 C++ 里另一个基本的编程范式。**它的核心思想是“抽象”和“封装”**，倡导的是把任务分解成一些高内聚低耦合的对象，这些对象互相通信协作来完成任务。它强调对象之间的关系和接口，而不是完成任务的具体步骤。

在 C++ 里，面向对象范式包括 class、public、private、virtual、this 等类相关的关键字，还有构造函数、析构函数、友元函数等概念。

**泛型编程**是自 STL（标准模板库）纳入到 C++ 标准以后才逐渐流行起来的新范式，核心思想是“一切皆为类型”，或者说是“参数化类型”“类型擦除”，使用模板而不是继承的方式来复用代码，所以运行效率更高，代码也更简洁。

在 C++ 里，泛型的基础就是 template 关键字，然后是庞大而复杂的标准库，里面有各种泛型容器和算法，比如 vector、map、sort，等等。

与“泛型编程”很类似的是**模板元编程**，这个词听起来好像很新，其实也有十多年的历史了，不过相对于前三个范式来说，确实“资历浅”。它的核心思想是“类型运算”，操作的数据是编译时可见的“类型”，所以也比较特殊，代码只能由编译器执行，而不能被运行时的 CPU 执行。

在讲编译阶段的时候我也说了，模板元编程是一种高级、复杂的技术，C++ 语言对它的支持也比较少，更多的是以库的方式来使用，比如 type_traits、enable_if 等。

最后一个**函数式**，它几乎和“面向过程”一样古老，但却直到近些年才走入主流编程界的视野。所谓的“函数式”并不是 C++ 里写成函数的子程序，而是数学意义上、无副作用的函数，**核心思想是“一切皆可调用”，通过一系列连续或者嵌套的函数调用实现对数据的处理**。

函数式早在 C++98 时就有少量的尝试（bind1st/bind2nd 等函数对象），但直到 C++11 引入了 Lambda 表达式，它才真正获得了可与其他范式并驾齐驱的地位。

常用的范式是“过程 + 对象 + 泛型”，再加上少量的“函数式”，慎用“模板元”。