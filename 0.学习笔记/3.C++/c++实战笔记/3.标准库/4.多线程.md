## 多线程

```c++
auto f = []()                // 定义一个lambda表达式
{
    cout << "tid=" <<
        this_thread::get_id() << endl;
};
thread t(f);                // 启动一个线程，运行函数f
```

首先，你要知道一个最基本但也最容易被忽视的常识：**“读而不写”就不会有数据竞争**。

所以，在 C++ 多线程编程里读取 const 变量总是安全的，对类调用 const 成员函数、对容器调用只读算法也总是线程安全的。

## 多线程开发实践

### 仅调用一次

程序免不了要初始化数据，这在多线程里却是一个不大不小的麻烦。因为线程并发，如果没有某种同步手段来控制，会导致初始化函数多次运行。

为此，C++ 提供了“仅调用一次”的功能，可以很轻松地解决这个问题。

这个功能用起来很简单，你要先声明一个 **once_flag** 类型的变量，最好是静态、全局的（线程可见），作为初始化的标志：

```c++
static std::once_flag flag;        // 全局的初始化标志
```

然后调用专门的 call_once() 函数，以函数式编程的方式，传递这个标志和初始化函数。这样 C++ 就会保证，即使多个线程重入 call_once()，也只能有一个线程会成功运行初始化。

```c++
auto f = []()                // 在线程里运行的lambda表达式
{   
    std::call_once(flag,      // 仅一次调用，注意要传flag
        [](){                // 匿名lambda，初始化函数，只会执行一次
            cout << "only once" << endl;
        }                  // 匿名lambda结束
    );                     // 在线程里运行的lambda表达式结束
};
thread t1(f);            // 启动两个线程，运行函数f
thread t2(f);
```

call_once() 完全消除了初始化时的并发冲突，在它的调用位置根本看不到并发和线程。所以，按照刚才说的基本原则，它是一个很好的多线程工具。

它也可以很轻松地解决多线程领域里令人头疼的“双重检查锁定”问题，你可以自己试一试，用它替代锁定来初始化。

### 线程局部存储

有的时候，全局变量并不一定是必须共享的，可能仅仅是为了方便线程传入传出数据，或者是本地 cache，而不是为了共享所有权。

换句话说，这应该是线程独占所有权，不应该在多线程之间共同拥有，术语叫“**线程局部存储**”（thread local storage）。

这个功能在 C++ 里由关键字 **thread_local** 实现，它是一个和 static、extern 同级的变量存储说明，有 thread_local 标记的变量在每个线程里都会有一个独立的副本，是“线程独占”的，所以就不会有竞争读写的问题。

```c++
thread_local int n = 0;        // 线程局部存储变量
auto f = [&](int x)           // 在线程里运行的lambda表达式，捕获引用
{   
    n += x;                   // 使用线程局部变量，互不影响
    cout << n;                // 输出，验证结果
};  
thread t1(f, 10);           // 启动两个线程，运行函数f
thread t2(f, 20);
```

### 原子变量

要想保证多线程读写共享数据的一致性，关键是**要解决同步问题**，不能让两个线程同时写，也就是“互斥”。

这在多线程编程里早就有解决方案了，就是互斥量（Mutex）。但它的成本太高，所以，对于小数据，应该采用“**原子化**”这个更好的方案。

所谓原子（atomic），在多线程领域里的意思就是不可分的。操作要么完成，要么未完成，不能被任何外部操作打断，总是有一个确定的、完整的状态。所以也就不会存在竞争读写的问题，不需要使用互斥量来同步，成本也就更低。

但不是所有的操作都可以原子化的，否则多线程编程就太轻松了。目前，C++ 只能让一些最基本的类型原子化，比如 atomic_int、atomic_long，等等：

```c++
using atomic_bool = std::atomic<bool>;    // 原子化的bool
using atomic_int  = std::atomic<int>;      // 原子化的int
using atomic_long = std::atomic<long>;    // 原子化的long
```

