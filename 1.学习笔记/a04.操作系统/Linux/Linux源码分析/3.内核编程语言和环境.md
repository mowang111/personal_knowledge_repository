汇编语言并不是单一的、统一的语言，而是一系列的语言，每种语言都是为特定的处理器架构设计的。汇编语言的种类与处理器架构的种类密切相关。例如，x86架构的汇编语言与ARM架构的汇编语言就大不相同。因此，可以说汇编语言的种类与现有的处理器架构种类一样多。

### 常见的汇编语言种类：

1. **x86汇编语言**：用于Intel和AMD的x86及x86_64架构处理器。
2. **ARM汇编语言**：用于ARM架构处理器。
3. **MIPS汇编语言**：用于MIPS架构处理器。
4. **PowerPC汇编语言**：用于PowerPC架构处理器。
5. **6502汇编语言**：用于6502架构的微处理器，这种处理器在早期的个人电脑和游戏机中很常见。
6. **AVR汇编语言**：用于AVR微控制器。
7. **等等**：几乎每种处理器架构都有其对应的汇编语言。

### Linux 0.1中的汇编语言

Linux 0.1是Linux内核的早期版本，由Linus Torvalds在1991年发布。这个版本的Linux主要是为基于x86架构的个人电脑设计的。因此，Linux 0.1中使用的汇编语言是**x86汇编语言**。

在Linux 0.1中，汇编语言主要用于实现与硬件直接交互的底层功能，例如：

- 启动过程（引导程序）
- 设置和管理处理器的各种模式（如实模式到保护模式的切换）
- 中断处理和中断向量表的初始化
- 低级的输入/输出操作
- 系统调用的实现

Linux 0.1中的汇编代码主要遵循AT&T语法，这是UNIX和类UNIX系统中常用的汇编语言语法。AT&T语法与Intel语法（另一种常见的x86汇编语言语法）在格式和一些细节上有所不同。例如，操作数的顺序在两种语法中是相反的，AT&T语法还会在寄存器名前加上百分号（%），而Intel语法则不会。

总的来说，汇编语言的种类非常多，每种处理器架构都有其对应的汇编语言。Linux 0.1使用的是x86架构的汇编语言，主要遵循AT&T语法。

在讨论x86架构的汇编语言时，实际上我们通常指的是两种主要的语法风格，而不是完全不同的语言。x86汇编语言本身是为x86架构的处理器设计的，但在书写和表示方式上，主要分为两种语法：

1. **Intel语法**：这是由Intel公司定义的，也是在Windows环境下最常见的汇编语言语法。Intel语法的特点是操作数的顺序是“目标在前，源在后”。例如，将一个寄存器的值移动到另一个寄存器的操作，会将目标寄存器写在前面。Intel语法广泛用于Intel的官方文档和大多数Windows平台的汇编编程。

2. **AT&T语法**：这种语法风格在UNIX和类UNIX系统（如Linux）中更为常见。与Intel语法相比，AT&T语法的主要区别在于操作数的顺序是相反的，即“源在前，目标在后”。此外，AT&T语法在寄存器名前加上`%`前缀，在立即数前加上`$`前缀，而且指令名后面通常会有一个用于表示操作数大小的字符（如`l`表示长字（32位），`w`表示字（16位），`b`表示字节（8位））。AT&T语法也支持更复杂的内存寻址模式的表示。

尽管这两种语法在表示方式上有所不同，但它们实际上描述的是相同的操作和指令集。转换工具和现代汇编器（如GNU Assembler，即`gas`）通常能够理解这两种语法，并允许开发者根据个人偏好或项目需求选择使用哪一种。

除了这两种主要的语法风格，还有一些汇编器可能会引入特定的宏或扩展，但这些通常被视为特定工具的特性，而不是不同的汇编语言。

总的来说，在x86架构下，汇编语言本身是统一的，差异主要在于Intel语法和AT&T语法这两种表示方式。
# 内核编程语言和环境

## 汇编器

在 Linux0.1x系统中使用了两种汇编器( Assembler)。

一种是能产生16位代码的<font color='red'>as86汇编器</font>，使用配套的d86链接器：另一种是<font color='red'>GNU的汇编器gas(as)</font>,使用GNU ld链接器来链接产生的目标文件。

as86汇编器仅用于编译内核中的`boot/bootsect.s` 引导扇区程序和实模式下的设置程序`boot/setup.s`,其余所有汇编语言（包括C语言产生的汇编程序）均使用gas来编译

### as汇编器

为了维持与gcc输出汇编程序的兼容性，as汇编器使用AT&T系统的汇编语法(下面简称为AT&T语法)。这种语法与 Intel汇编程序使用的语法(简称 Intel语法)很不一样，它们之间的主要区别有一些几点：

+ <font color='red'>AT&T语法中立即操作数前面要加一个字符\'\$\'</font>：寄存器操作数名前要加字符百分号';绝对跳转/调用(相对于与程序计数器有关的跳转/调用)操作数前面要加星号'*'。而 Intel汇编语法均没有这些限制。
+ <font color='red'>AT&T语法与 Intell语法使用的源和目的操作数次序正好相反</font>。AT&T的源和目的操作数是从左到右”源，目的'。例如 Intel的语句`add eax,4`对应AT&T的`addl $4,%eax`。
+ <font color='red'>AT&T语法中内存操作数的长度（宽度）由操作码最后一个字符来确定</font>。<font color='red'>作码后缀冒和分别指示内存引用宽度为8位字节(byte)、16位字(Word)和32位长字(long).</font>Intel语法则通过在内存操作数前使用前缀`byte prt`，`word ptr`和 `dword ptr`来达到同样目的。因此，Intel的语句`mov al, byte ptr foo`对应于AT&T的语句`move $foo,%a`。
+ AT&T语法中立即形式的远跳转和远调用为`ljmp/ lcall $section,$offset`,而 Intel的是`jmp/call far section: offset`。同样，AT&T语法中远返回指令`lret $stack-adjust`对应 Intel的`ret far stack-adjust`。
+ AT&T汇编器不提供对多代码段程序的支持，UNIX类操作系统要求所有代码在一个段中