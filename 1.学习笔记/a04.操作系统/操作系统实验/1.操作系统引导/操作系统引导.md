此次实验的基本内容是：

1. 阅读《Linux内核完全注释》的第6章，对计算机和Linux 0.11的引导过程进行初步的了解；
2. 按照下面的要求改写0.11的引导程序bootsect.s
3. 有兴趣同学可以做做进入保护模式前的设置程序setup.s。

改写bootsect.s主要完成如下功能：

- [x] 1. bootsect.s能在屏幕上打印一段提示信息“XXX is booting...”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等（可以上论坛上秀秀谁的OS名字最帅，也可以显示一个特色logo，以表示自己操作系统的与众不同。）

改写setup.s主要完成如下功能：

- [ ] 1. bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行"Now we are in SETUP"。
- [ ] 2. setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。
- [ ] 3. setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。
# 任务一 打印提示信息
主要修改/boot/bootsect.s中的代码：
```as
! Print some inane message

        mov     ah,#0x03                ! read cursor pos
        xor     bh,bh
        int     0x10

        mov     cx,#24
        mov     bx,#0x0007              ! page 0, attribute 7 (normal)
        mov     bp,#msg1
        mov     ax,#0x1301              ! write string, move cursor
        int     0x10


msg1:
        ! 插入回车换行符
        .byte 13,10
        ! 定义消息内容
        .ascii "Loading system ..."
        ! 再次插入回车换行符
        .byte 13,10,13,10
```

上述信息共24个字符，下面将他修改为“crzos is booting ...”，加上换行空格，共26个字符。

```as
! Print some inane message

        mov     ah,#0x03                ! read cursor pos
        xor     bh,bh
        int     0x10

        mov     cx,#26
        mov     bx,#0x0007              ! page 0, attribute 7 (normal)
        mov     bp,#msg1
        mov     ax,#0x1301              ! write string, move cursor
        int     0x10


msg1:
        ! 插入回车换行符
        .byte 13,10
        ! 定义消息内容
        .ascii "crzos is booting ..."
        ! 再次插入回车换行符
        .byte 13,10,13,10
```
![[修改启动提示信息.png]]

# 任务二 输出setup
在setup.s中添加代码：
```as
! now, we are in setup.s
! cs = ds = es
        mov     ax,cs
        mov     ds,ax
        mov     es,ax
! print some message

        mov     ah,#0x03                ! read cursor pos
        xor     bh,bh
        int     0x10

        mov     cx,#25
        mov     bx,#0x0007              ! page 0, attribute 7 (normal)
        mov     bp,#setup_msg
        mov     ax,#0x1301              ! write string, move cursor
        int     0x10

setup_msg:
        .byte 13,10
        .ascii "now we are in setup"
        .byte 13,10,13,10
```

> 尤其注意添加cs = ds = es代码
> 主要是es 要 = cs，否则不会正常显示
> ？？？不理解，待研究

> #中断向量表
> 中断向量表（Interrupt Vector Table，简称 IVT）是在早期 x86 架构的计算机系统中用于处理中断的一种数据结构。它位于内存的低端，即从物理地址 0x00000 开始的 1KB（1024 字节）空间内。
> 每个中断向量在表中占用 4 个字节，分别存储了一个中断服务例程（ISR）的段地址和偏移量。因为每个向量占用 4 字节，所以这个表能够容纳 256 个中断向量（1024 字节 / 4 字节/向量 = 256 向量）。
> 这些中断可以是由硬件（如按键按下、时钟信号、外设请求等）产生的硬件中断，也可以是由软件指令 INT n 引发的软件中断。操作系统和其他系统软件会在初始化时设置这些向量，以确保当中断发生时，能跳转到正确的处理函数去响应。
> IVT 的结构可以简化表示如下：
```
+------------------+ 0x00000
| 中断 0 的偏移量  |
| 中断 0 的段地址  |
+------------------+ 0x00004
| 中断 1 的偏移量  |
| 中断 1 的段地址  |
+------------------+
|                  |
| ...              |
|                  |
+------------------+ 0x003FC
| 中断 255 的偏移量 |
| 中断 255 的段地址 |
+------------------+ 0x00400
```
在实模式下，IVT 是 CPU 处理中断的关键数据结构。当中断发生时：
1. CPU 会立即完成当前指令的执行。
2. 根据中断类型（中断号），CPU 查询 IVT，找到对应中断号的中断服务例程地址。
3. CPU 将标志寄存器（FLAGS）、代码段寄存器（CS）和指令指针寄存器（IP）压栈。
4. CPU 跳转到该中断服务例程执行相应的中断处理。
处理完中断后，中断服务例程通常会执行一个 `iret` 指令，这个指令会从栈中弹出之前保存的 IP、CS 和 FLAGS 寄存器的值，恢复 CPU 到中断发生前的状态，继续执行剩余的程序。
随着计算机系统的发展，特别是在保护模式和现代操作系统中，中断处理机制变得更加复杂，使用了中断描述符表（IDT）代替了实模式下的 IVT。





