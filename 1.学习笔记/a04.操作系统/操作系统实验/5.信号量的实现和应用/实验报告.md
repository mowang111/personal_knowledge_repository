pc.c
```c
#include <semaphore.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>

#define N 5
#define M 500

FILE *fp_write, *fp_read;
sem_t *empty, *full, *mutex;


void Producer(){
    int i;
    fflush(stdout);                                 
    for(i = 0; i < M; i++){
        sem_wait(empty);
        sem_wait(mutex);
        fwrite(&i, sizeof(int), 1, fp_write);
        fflush(fp_write);
        sem_post(mutex);
        sem_post(full);
    }
}

void Consumer(){
    int num;
    fflush(stdout);
    while(1){
        sem_wait(full);
        sem_wait(mutex);
        fread(&num, sizeof(int), 1, fp_read);
        printf("%d: %d\n", getpid(), num);
        fflush(stdout);
        sem_post(mutex);
        sem_post(empty);
    }
}

int main(){
    int i;
    fp_write = fopen("buffer.txt", "w+");
    fp_read = fopen("buffer.txt", "r");
    setvbuf(fp_read, NULL, _IONBF, 0);
    if(fp_write == NULL || fp_read == NULL){
        printf("File open error!\n");
        exit(1);
    }

    empty = sem_open("/myempty", 10);
    if(!empty){
        printf("sem_open empty error!\n");
    }
    full = sem_open("/myfull",  0);
    if(!full){
        printf("sem_open full error!\n");
    }
    mutex = sem_open("/mymutex", 1);
    if(!mutex){
        printf("sem_open mutex error!\n");
    }

    for(i = 0; i < N; i++){
        if(fork() == 0){
            Consumer();
            exit(0);
        }
    }

    Producer();

    for(i = 0; i < N; i++){
        wait(NULL);
    }

    fclose(fp_write);
    fclose(fp_read);
    sem_unlink("/myempty");
    sem_unlink("/myfull");
    sem_unlink("/mymutex");

    return 0;
}
```

增加四个系统调用`sys_sem_open`, `sys_sem_wait`, `sys_sem_post`, `sys_sem_unlink`,具体增加的步骤同实验2系统调用，这里只说明函数实现方式：
semaphore.h
```c
#define __LIBRARY__
#include <unistd.h>
#ifndef _LINUX_SEM_H
#define _LINUX_SEM_H

#include <linux/sched.h>

#define MAX_SEM_NUM 10
#define SEM_NAME_LEN 32

typedef struct sem_t sem_t;

struct sem_t {
    char * name;
    unsigned int sem_value;
    struct task_struct * sem_wait;
};

struct sem_t sem_array[MAX_SEM_NUM];
unsigned int sem_bitmap = 0;


_syscall2(sem_t*, sem_open, const char*, name, unsigned int, value);
_syscall1(int, sem_wait, sem_t*, sem);
_syscall1(int, sem_post, sem_t*, sem);
_syscall1(int, sem_unlink, const char*, name);


#endif



```