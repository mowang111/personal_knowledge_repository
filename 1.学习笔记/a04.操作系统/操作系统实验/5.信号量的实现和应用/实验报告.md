# pc.c
```c
#include <semaphore.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>

#define N 5
#define M 500

FILE *fp_write, *fp_read;
sem_t *empty, *full, *mutex;


void Producer(){
    int i;
    fflush(stdout);                                 
    for(i = 0; i < M; i++){
        sem_wait(empty);
        sem_wait(mutex);
        fwrite(&i, sizeof(int), 1, fp_write);
        fflush(fp_write);
        sem_post(mutex);
        sem_post(full);
    }
}

void Consumer(){
    int num;
    fflush(stdout);
    while(1){
        sem_wait(full);
        sem_wait(mutex);
        fread(&num, sizeof(int), 1, fp_read);
        printf("%d: %d\n", getpid(), num);
        fflush(stdout);
        sem_post(mutex);
        sem_post(empty);
    }
}

int main(){
    int i;
    fp_write = fopen("buffer.txt", "w+");
    fp_read = fopen("buffer.txt", "r");
    setvbuf(fp_read, NULL, _IONBF, 0);
    if(fp_write == NULL || fp_read == NULL){
        printf("File open error!\n");
        exit(1);
    }

    empty = sem_open("/myempty", 10);
    if(!empty){
        printf("sem_open empty error!\n");
    }
    full = sem_open("/myfull",  0);
    if(!full){
        printf("sem_open full error!\n");
    }
    mutex = sem_open("/mymutex", 1);
    if(!mutex){
        printf("sem_open mutex error!\n");
    }

    for(i = 0; i < N; i++){
        if(fork() == 0){
            Consumer();
            exit(0);
        }
    }

    Producer();

    for(i = 0; i < N; i++){
        wait(NULL);
    }

    fclose(fp_write);
    fclose(fp_read);
    sem_unlink("/myempty");
    sem_unlink("/myfull");
    sem_unlink("/mymutex");

    return 0;
}
```

# sh
增加四个系统调用`sys_sem_open`, `sys_sem_wait`, `sys_sem_post`, `sys_sem_unlink`,具体增加的步骤同实验2系统调用，这里只说明函数实现方式：
semaphore.h
```c
#define __LIBRARY__
#include <unistd.h>
#ifndef _LINUX_SEM_H
#define _LINUX_SEM_H

#include <linux/sched.h>

#define MAX_SEM_NUM 10
#define SEM_NAME_LEN 32

typedef struct sem_t sem_t;

struct sem_t {
    char * name;
    unsigned int sem_value;
    struct task_struct * sem_wait;
};

struct sem_t sem_array[MAX_SEM_NUM];
unsigned int sem_bitmap = 0;


_syscall2(sem_t*, sem_open, const char*, name, unsigned int, value);
_syscall1(int, sem_wait, sem_t*, sem);
_syscall1(int, sem_post, sem_t*, sem);
_syscall1(int, sem_unlink, const char*, name);


#endif
```

semaphore.c
```c
#include <semaphore.h>
#include <asm/system.h>
#include <asm/segment.h>
#include <linux/kernel.h>

struct sem_t* sys_sem_open(const char *name, unsigned int value) {
    // assign num for sem
    int i = 0;
    int name_len = 0;
    char c;
    for(i = 0; i < MAX_SEM_NUM; i++){
        if(!(sem_bitmap & (1 << i))){
            sem_bitmap |= (1 << i);
            break;
        }
    }
    if(i == MAX_SEM_NUM){
        return NULL;
    }
    struct sem_t* sem = &sem_array[i];
    sem->name = malloc(SEM_NAME_LEN);
    
    while(c = get_fs_byte(name++)){
        sem->name[name_len] = c;
        name_len++;
    }
    sem->name[name_len] = '\0';
    printk("sem_open sem name: %s, addr: %x\n", sem->name, sem);
    sem->sem_value = value;
    sem->sem_wait = NULL;
    return sem;
}

int sys_sem_wait(struct sem_t* sem) {
    while(sem->sem_value <= 0){
        sleep_on(&sem->sem_wait);
    }
    cli();
    sem->sem_value--;
    sti();
    return 0;
}

int sys_sem_post(struct sem_t* sem) {
    cli();
    sem->sem_value++;
    sti();
    wake_up(&sem->sem_wait);
    return 0;
}

int sys_sem_unlink(const char *name) {
    char kname[SEM_NAME_LEN];
    int name_len = 0;
    char c;
    while(c = get_fs_byte(name++)){
        kname[name_len] = c;
        name_len++;
    }
    kname[name_len] = '\0';
    printk("sem_unlink name: %s\n", kname);
    int i = 0;
    for(i = 0; i < MAX_SEM_NUM; i++){
        if(strcmp(sem_array[i].name, kname) == 0){
            sem_bitmap &= ~(1 << i);
            free(sem_array[i].name);
            return 0;
        }
    }
    return -1;
}
```

# 实验结果