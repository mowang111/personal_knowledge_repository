---
title:
---

# 实验目标
本次实验主要将linux0.11中采用的TSS切换部分（switch_to实现）去掉，改写成一段基于堆栈切换的代码程序。
![[基于tss的进程切换过程.jpg]]
```
#define _TSS(n) ((((unsigned long) n)<<4)+(FIRST_TSS_ENTRY<<3))
/*
 *	switch_to(n) should switch tasks to task nr n, first
 * checking that n isn't the current task, in which case it does nothing.
 * This also clears the TS-flag if the task we switched to has used
 * tha math co-processor latest.
 */
#define switch_to(n) {\
struct {long a,b;} __tmp; \
__asm__("cmpl %%ecx,current\n\t" \
	"je 1f\n\t" \
	"movw %%dx,%1\n\t" \
	"xchgl %%ecx,current\n\t" \
	"ljmp *%0\n\t" \
	"cmpl %%ecx,last_task_used_math\n\t" \
	"jne 1f\n\t" \
	"clts\n" \
	"1:" \
	::"m" (*&__tmp.a),"m" (*&__tmp.b), \
	"d" (_TSS(n)),"c" ((long) task[n])); \
}
```
> switch_to函数解释
> 1. 是否是要切换到当前进程，不是则继续
> 2. 将即将切换的tss段描述符（2个字节）放到_tmp.b（long占四个字节，高2字节不用）中
> 3. 注意ljmp指令执行时，当指定参数对应的段描述符是tss段时，就会执行cpu切换工作，而不是长跳转，具体来说，CPU 会进行以下操作：
> 	1. **保存当前任务状态**：当前任务的状态会被保存到当前任务状态段（TSS）中。这包括所有的寄存器状态、堆栈指针等。
> 	2. **加载新任务状态**：CPU 会从目标任务的 TSS 中加载新的任务状态。这包括新的寄存器状态、堆栈指针等。
> 	3. **切换任务**：CPU 会切换到新的任务，执行新的任务的代码。
> 4. 宏`_TSS(n)`对应进程n的TSS在GDT表中的位置，又因为每个进程对应一个TSS和一个LDT，每个描述符的长度都是8个字节，所以要乘以16

# 实验步骤
![[基于内核栈完成进程切换.png]]
上图是基于内核栈完成进程切换的基本步骤，主要在switch_to中体现：

## 重写switch_to （system_call.s中）
```c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;
	struct task_struct * pnext;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE)
				(*p)->state=TASK_RUNNING;
		}

/* this is the scheduler proper: */

	while (1) {
		c = -1;
		next = 0;
		/*notice：这里一定要加，否则当没有进程调度时，pnext是空值*/
		pnext = task[next];
		
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i, pnext = *p;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	switch_to(pnext, _LDT(next));
}
```

```c
switch_to:
	pushl %ebp
	movl %esp,%ebp
	pushl %ecx
	pushl %ebx
	pushl %eax
	movl 8(%ebp),%ebx
	cmpl %ebx,current
	je 1f
	! 切换PCB
	movl %ebx,%eax
	xchgl %eax,current
	! 小插曲：利用0号进程的tss段，将其ESP0指向当前进程内核栈
	movl tss,%ecx
	addl $4096,%ebx
	movl %ebx,ESP0(%ecx)
	! 切换内核栈，这里注意task_struct中需要新增kernel_stack这个域
	movl %esp,kernel_stack(%eax)
	movl 8(%ebp),%ebx
	movl kernel_stack(%ebx),%esp
	! 切换LDT
	movl 12(%ebp),%ecx
	lldt %cx
	! 小插曲：由于影子寄存器的存在，需要重新载入fs寄存器
	movl $0x17,%ecx
    mov %cx,%fs
    ! 处理协处理器，暂不分析
	cmpl %eax,last_task_used_math
    jne 1f
    clts
1: 	popl %eax
	popl %ebx
	popl %ecx
	popl %ebp
	ret
```
> 在 Linux 0.11 中，每个进程的内核栈和 PCB（进程控制块）都被分配在同一页（4KB）内存中。PCB 位于页的低地址部分，内核栈位于页的高地址部分。内核栈从页的高地址向低地址增长，而 PCB 位于低地址部分。

在`task_struct`结构体中增加`kernelstack`域：
```c
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
	long counter;
	long priority;
	long kernelstack;
	...
}
```

### 注意
1. 增加`kernelstack`域后，需要对应修改`system_call.s`中的偏移值：
```c
state	= 0		# these are offsets into the task_struct.
counter	= 4
priority = 8
kernel_stack = 12
signal	= 16
sigaction = 20		# MUST be 16 (=len of sigaction)
blocked = (32*16) + 20
```
之前没有修改此处，造成了进程`signal`的取值错误，本来应该是0，结果取成了乱七八糟的值，结果判断进程退出，系统不停重启，这个是在调试`ret_from_sys_call`的过程中发现`current->signal`和赋值后的`ebx`不相同，`ebx`应该为0，却不为0：
```c
movl signal(%eax),%ebx
```
2. `schedule()`函数中的`pnext`一定要记得赋值：
```c
		pnext = task[next];
```
当没有进程调度时，pnext是空值，之前一直出现`page_fault`的问题，一直没有调试出来，结果参考其他人代码才发现，现象如下：
![[系统宕机.gif]]
## 修改现在的fork() 
需要将新建进程的用户栈、用户程序地址和其内核栈关联起来，因为使用tss切换时没有做这样的关联。
fork()要求父子进程共享用户代码、用户数据和用户堆栈。
![[fork中父子进程的用户栈内核栈之间的关系.jpg]]

这里对应切回用户栈和用户代码的操作，`switch_to`最后的`ret`会跳到从内核栈中弹出的地址处执行，对应`first_return_from_kernel`。
```c
krnstack = (long*)(PAGE_SIZE + (long) p);

/*下面这部分和first_return_from_kernel中的iret对应
也使得子进程与父进程共享用户代码、用户数据和用户堆栈*/
*(--krnstack) = ss & 0xffff; /*Segment selector for user stacks*/
*(--krnstack) = esp; /*offset of user stacks*/
*(--krnstack) = eflags;
*(--krnstack) = cs & 0xffff;
*(--krnstack) = eip;
/*下面这部分和first_return_from_kernel中的pop寄存器对应*/
*(--krnstack) = ds & 0xffff;
*(--krnstack)  = es & 0xffff;
*(--krnstack)  = fs & 0xffff;
*(--krnstack)  = gs & 0xffff;
*(--krnstack)  = esi;
*(--krnstack)  = edi;
*(--krnstack)  = edx;
/*first_return_from_kernel地址*/
*(--krnstack)  = (long) first_return_from_kernel;
/*下面这部分对应switch_to函数中的1标号处的pop寄存器
因为运行到1标号时，已经切换到新的进程，如果新建进程的内核栈没有与之对应的寄存器，就会出错*/
*(--krnstack) = ebp;
*(--krnstack) = ecx;
*(--krnstack) = ebx;
*(--krnstack) = 0;		/* eax */
p->kernelstack = krnstack;
```
`first_return_from_kernel`就担负起跳回用户态的重任，就是设置相应的寄存器，与fork()初始化操作对应。
```c
first_return_from_kernel:
	popl %edx
	popl %edi
	popl %esi
	pop %gs
	pop %fs
	pop %es
	pop %ds
	iret
```
> IRET 指令在从特权级返回时会处理更多的寄存器，具体情况如下：
> • 当从低特权级（如用户模式，CPL=3）返回到高特权级（如内核模式，CPL=0）时，需要恢复更多的寄存器状态，这包括 SS 和 ESP 寄存器。
> 1. POP EIP（指令指针）
> 2. POP CS（代码段寄存器）
> 3. POP EFLAGS（标志寄存器）
> 4. POP ESP（栈指针）
> 5. POP SS（栈段寄存器）
> • 而在相同特权级之间的中断处理，则只需要恢复 EIP、CS 和 EFLAGS 寄存器。
> 1. POP EIP
> 2. POP CS
> 3. POP EFLAGS

# 实验结果
正常运行
![[基于内核栈切换线程实验结果.png]]


