本次实验的基本内容是：

- [x] 用Bochs调试工具跟踪Linux 0.11的地址翻译（地址映射）过程，了解IA-32和Linux 0.11的内存管理机制；
- [x] 在Ubuntu上编写多进程的生产者—消费者程序，用共享内存做缓冲区；
- [ ] 在信号量实验的基础上，为Linux 0.11增加共享内存功能，并将生产者—消费者程序移植到Linux 0.11。

![[Linux 0.11地址翻译调试.png]]


producer.c
```c

```

consumer.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <semaphore.h>

const int MAX_BUFFER = 10;
const int N = 500;

/*semaphore*/
sem_t *empty, *full, *mutex;

/*shared memery*/
int shmid;
key_t key = 1234;
int *shm;

void consumer(){
    int i;
    for(i = 0; i < N; i++){
        sem_wait(full);
        sem_wait(mutex);
        printf("%d\n", shm[i]);
        fflush(stdout);
        sem_post(mutex);
        sem_post(empty);
    }
}

int main(){
    /*create shared memory*/
    shmid = shmget(key, sizeof(int)*N, IPC_CREAT | 0666);
    if(shmid < 0){
        printf("shmget error!\n");
        return 1;
    }
    shm = shmat(shmid, NULL, 0);
    if(shm == (int *)-1){
        printf("shm error!\n");
        return 1;
    }

    /*initialize semaphore*/
    empty = sem_open("myempty", O_CREAT, 0666, MAX_BUFFER);
    full = sem_open("myfull", O_CREAT, 0666, 0);
    mutex = sem_open("mymutex", O_CREAT, 0666, 1);

    consumer();

    sem_unlink("myempty");
    sem_unlink("myfull");
    sem_unlink("mymutex");
    return 0;
}
```
