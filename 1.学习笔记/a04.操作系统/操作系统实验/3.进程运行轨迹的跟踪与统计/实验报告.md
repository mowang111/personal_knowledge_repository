就绪与运行之间的状态转移（记住是两者之间的相互状态转移）是通过 `schedule（）`函数完成的；运行到阻塞的转移依靠的是 `sleep-on（）`和 `interruptible _sleep_on()`，进程通过系统调用 `sys-pause（）`和 `sys-waitpid（）` 可以主动进入阻塞态；阻塞到就绪的转移依靠的是 `wake_up（）`。所以只要在这些函数的适当位置插人适当的处理语句就能完成进程运行轨迹的全面跟踪了。

# 自定义打印日志的函数
> 可变参数使用和原理：[[可变参数]]
```c
static char logbuf[1024];
int fprintk(int fd, const char *fmt, ...)
{
	va_list args;
	int count;
	struct file * file;
	struct m_inode * inode;
	va_start(args, fmt);
	count = vsprintf(logbuf, fmt, args);
	va_end(args);
	if (fd == 3) {
		// get file by 0 process
		if (!(file=task[0]->filp[fd]))    /* 从进程0的文件描述符表中得到文件句柄 */
            return 0;
		inode = file->f_inode;
		__asm__("push %%fs\n\t"
				"push %%ds\n\t"
				"pop %%fs\n\t"
				"pushl %0\n\t"
				"pushl $logbuf\n\t"
				"pushl %1\n\t"
				"pushl %2\n\t"
				"call file_write\n\t"
				"addl $12,%%esp\n\t"
				"popl %0\n\t"
				"pop %%fs\n\t"
				::"r"(count), "r"(file), "r"(inode):"ax","cx","dx");
	}
	
	return count;
}
```
# 适当位置添加打印语句
## sched.c
```c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE){
				(*p)->state=TASK_RUNNING;
				fprintk(3, "%ld\t%c\t%ld\n", (*p)->pid, 'J', jiffies);
			}
		}

/* this is the scheduler proper: */

	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	if(task[next]->pid != current->pid){
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
		fprintk(3, "%ld\t%c\t%ld\n", task[next]->pid, 'R', jiffies);
	}
		
	switch_to(next);
}

int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
	schedule();
	return 0;
}

void sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp = *p;
	*p = current;
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();
	if (tmp){
		tmp->state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
	}
		
}

void interruptible_sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp=*p;
	*p=current;
repeat:	current->state = TASK_INTERRUPTIBLE;
	schedule();
	if (*p && *p != current) {
		(**p).state=0;
		fprintk(3, "%ld\t%c\t%ld\n", (**p).pid, 'J', jiffies);
		goto repeat;
	}
	*p=NULL;
	if (tmp){
		tmp->state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
	}
		
}

void wake_up(struct task_struct **p)
{
	if (p && *p) {
		(**p).state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
		*p=NULL;
	}
}
```

## exit.c
```c
int do_exit(long code)
{
	int i;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
	for (i=0 ; i<NR_TASKS ; i++)
		if (task[i] && task[i]->father == current->pid) {
			task[i]->father = 1;
			if (task[i]->state == TASK_ZOMBIE)
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
	for (i=0 ; i<NR_OPEN ; i++)
		if (current->filp[i])
			sys_close(i);
	iput(current->pwd);
	current->pwd=NULL;
	iput(current->root);
	current->root=NULL;
	iput(current->executable);
	current->executable=NULL;
	if (current->leader && current->tty >= 0)
		tty_table[current->tty].pgrp = 0;
	if (last_task_used_math == current)
		last_task_used_math = NULL;
	if (current->leader)
		kill_session();
	current->state = TASK_ZOMBIE;
	current->exit_code = code;
	// before father wakes up, children exits
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'E', jiffies);
	tell_father(current->father);
	schedule();
	return (-1);	/* just to suppress warnings */
}
```
## fock.c
```c
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
	struct task_struct *p;
	int i;
	struct file *f;

	p = (struct task_struct *) get_free_page();
	if (!p)
		return -EAGAIN;
	task[nr] = p;
	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;
	p->father = current->pid;
	p->counter = p->priority;
	p->signal = 0;
	p->alarm = 0;
	p->leader = 0;		/* process leadership doesn't inherit */
	p->utime = p->stime = 0;
	p->cutime = p->cstime = 0;
	p->start_time = jiffies;
	p->tss.back_link = 0;
	p->tss.esp0 = PAGE_SIZE + (long) p;
	p->tss.ss0 = 0x10;
	p->tss.eip = eip;
	p->tss.eflags = eflags;
	p->tss.eax = 0;
	p->tss.ecx = ecx;
	p->tss.edx = edx;
	p->tss.ebx = ebx;
	p->tss.esp = esp;
	p->tss.ebp = ebp;
	p->tss.esi = esi;
	p->tss.edi = edi;
	p->tss.es = es & 0xffff;
	p->tss.cs = cs & 0xffff;
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
	p->tss.ldt = _LDT(nr);
	p->tss.trace_bitmap = 0x80000000;
	if (last_task_used_math == current)
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
	if (copy_mem(nr,p)) {
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
	for (i=0; i<NR_OPEN;i++)
		if ((f=p->filp[i]))
			f->f_count++;
	if (current->pwd)
		current->pwd->i_count++;
	if (current->root)
		current->root->i_count++;
	if (current->executable)
		current->executable->i_count++;
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
	p->state = TASK_RUNNING;	/* do this last, just in case */
	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'N', jiffies);
	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'J', jiffies);
	return last_pid;
}
```

# 编写测试程序process.c
```c


```
```
1	N	48
1	J	48
0	W	48
1	R	48
2	N	49
2	J	49
1	W	49
2	R	49
3	N	64
3	J	64
2	W	64
3	R	64
3	W	68
2	R	68
2	E	73
1	J	73
2	W	73
1	R	73
4	N	74
4	J	74
1	W	74
4	R	74
5	N	106
5	J	106
4	W	107
5	R	107
5	J	109
5	E	109
5	W	109
4	R	109
4	W	115
0	R	115
0	J	579
0	W	579
4	R	579
4	W	579
0	R	579
0	J	598
0	W	598
4	R	598
4	W	598
0	R	598
0	J	629
0	W	629
4	R	629
4	W	630
0	R	630
0	J	658
0	W	658
4	R	658
4	W	658
0	R	658
0	J	726
0	W	726
4	R	726
4	W	726
0	R	726
0	J	748
0	W	748
4	R	748
4	W	748
0	R	748
0	J	773
0	W	773
4	R	773
4	W	779
0	R	779
0	J	808
0	W	808
4	R	808
4	W	808
0	R	808
0	J	949
0	W	949
4	R	949
4	W	949
0	R	949
0	J	958
0	W	958
4	R	958
4	W	958
0	R	958
0	J	1018
0	W	1018
4	R	1018
4	W	1018
0	R	1018
0	J	1036
0	W	1036
4	R	1036
4	W	1036
0	R	1036
0	J	1048
0	W	1048
4	R	1048
4	W	1053
0	R	1053
0	J	1108
0	W	1108
4	R	1108
4	W	1108
0	R	1108
0	J	1228
0	W	1228
4	R	1228
6	N	1229
6	J	1229
4	W	1230
6	R	1230
7	N	1233
7	J	1233
8	N	1233
8	J	1233
6	W	1234
8	R	1234
8	W	1249
7	R	1249
7	W	1264
8	R	1264
8	W	1279
7	R	1279
7	W	1294
8	R	1294
8	W	1309
7	R	1309
7	W	1324
8	R	1324
8	W	1339
7	R	1339
7	W	1354
8	R	1354
8	W	1369
7	R	1369
7	W	1384
8	R	1384
8	W	1399
7	R	1399
7	W	1414
8	R	1414
8	W	1424
7	R	1424
7	W	1434
0	R	1434
8	J	1525
0	W	1525
8	R	1525
7	J	1545
8	W	1545
7	R	1545
7	W	1562
8	R	1562
8	W	1577
7	R	1577
7	W	1592
8	R	1592
8	W	1607
7	R	1607
7	W	1622
8	R	1622
8	W	1637
7	R	1637
7	W	1652
8	R	1652
8	W	1667
7	R	1667
7	W	1682
8	R	1682
8	W	1697
7	R	1697
7	W	1712
8	R	1712
8	W	1717
7	R	1717
7	W	1725
0	R	1725
8	J	1818
0	W	1818
8	R	1818
7	J	1828
8	W	1828
7	R	1828
7	W	1835
8	R	1835
8	W	1850
7	R	1850
7	W	1865
8	R	1865
8	W	1880
7	R	1880
7	W	1895
8	R	1895
8	W	1910
7	R	1910
7	W	1925
8	R	1925
8	W	1940
7	R	1940
7	W	1955
8	R	1955
8	W	1970
7	R	1970
7	W	1985
8	R	1985
8	W	2000
7	R	2000
7	W	2015
8	R	2015
8	W	2015
7	R	2015
7	W	2018
0	R	2018
8	J	2116
0	W	2116
8	R	2116
7	J	2131
8	W	2131
7	R	2131
7	W	2143
8	R	2143
8	W	2158
7	R	2158
7	W	2173
8	R	2173
8	W	2188
7	R	2188
7	W	2203
8	R	2203
8	W	2218
7	R	2218
7	W	2233
8	R	2233
8	W	2248
7	R	2248
7	W	2263
8	R	2263
8	W	2278
7	R	2278
7	W	2293
8	R	2293
8	W	2303
7	R	2303
7	W	2316
0	R	2316
8	J	2404
0	W	2404
8	R	2404
7	J	2424
8	W	2424
7	R	2424
7	W	2440
8	R	2440
8	W	2455
7	R	2455
7	W	2470
8	R	2470
8	W	2485
7	R	2485
7	W	2500
8	R	2500
8	W	2515
7	R	2515
7	W	2530
8	R	2530
8	W	2545
7	R	2545
7	W	2560
8	R	2560
8	W	2575
7	R	2575
7	W	2590
8	R	2590
8	W	2595
7	R	2595
7	W	2604
0	R	2604
8	J	2696
0	W	2696
8	R	2696
8	E	2696
6	J	2696
8	W	2696
6	R	2696
6	W	2696
0	R	2696
7	J	2705
0	W	2705
7	R	2705
7	E	2705
6	J	2705
7	W	2705
6	R	2705
6	E	2706
4	J	2706
6	W	2706
4	R	2706
9	N	2707
9	J	2707
4	W	2707
9	R	2707
9	J	2709
9	E	2710
9	W	2710
4	R	2710
4	W	2710
0	R	2710
0	J	2908
0	W	2908
4	R	2908
4	W	2908
0	R	2908
0	J	2938
0	W	2938
4	R	2938
4	W	2938
0	R	2938
0	J	2968
0	W	2968
4	R	2968
4	W	2968
0	R	2968
0	J	2990
0	W	2990
4	R	2990
4	W	2990
0	R	2990
0	J	3043
0	W	3043
4	R	3043
4	W	3043
0	R	3043
0	J	3058
0	W	3058
4	R	3058
4	W	3058
0	R	3058
3	J	3067
0	W	3067
3	R	3067
3	W	3067
0	R	3067
0	J	3088
0	W	3088
4	R	3088
4	W	3088
0	R	3088
0	J	3109
0	W	3109
4	R	3109
4	W	3109
0	R	3109
0	J	3148
0	W	3148
4	R	3148
10	N	3150
10	J	3150
4	W	3150
10	R	3151

```

