就绪与运行之间的状态转移（记住是两者之间的相互状态转移）是通过 `schedule（）`函数完成的；运行到阻塞的转移依靠的是 `sleep-on（）`和 `interruptible _sleep_on()`，进程通过系统调用 `sys-pause（）`和 `sys-waitpid（）` 可以主动进入阻塞态；阻塞到就绪的转移依靠的是 `wake_up（）`。所以只要在这些函数的适当位置插人适当的处理语句就能完成进程运行轨迹的全面跟踪了。

# 自定义打印日志的函数
> 可变参数使用和原理：[[可变参数]]
```c
static char logbuf[1024];
int fprintk(int fd, const char *fmt, ...)
{
	va_list args;
	int count;
	struct file * file;
	struct m_inode * inode;
	va_start(args, fmt);
	count = vsprintf(logbuf, fmt, args);
	va_end(args);
	if (fd == 3) {
		// get file by 0 process
		if (!(file=task[0]->filp[fd]))    /* 从进程0的文件描述符表中得到文件句柄 */
            return 0;
		inode = file->f_inode;
		__asm__("push %%fs\n\t"
				"push %%ds\n\t"
				"pop %%fs\n\t"
				"pushl %0\n\t"
				"pushl $logbuf\n\t"
				"pushl %1\n\t"
				"pushl %2\n\t"
				"call file_write\n\t"
				"addl $12,%%esp\n\t"
				"popl %0\n\t"
				"pop %%fs\n\t"
				::"r"(count), "r"(file), "r"(inode):"ax","cx","dx");
	}
	
	return count;
}
```
# 适当位置添加打印语句
## sched.c
```c
void schedule(void)
{
	int i,next,c;
	struct task_struct ** p;

/* check alarm, wake up any interruptible tasks that have got a signal */

	for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
		if (*p) {
			if ((*p)->alarm && (*p)->alarm < jiffies) {
					(*p)->signal |= (1<<(SIGALRM-1));
					(*p)->alarm = 0;
				}
			if (((*p)->signal & ~(_BLOCKABLE & (*p)->blocked)) &&
			(*p)->state==TASK_INTERRUPTIBLE){
				(*p)->state=TASK_RUNNING;
				fprintk(3, "%ld\t%c\t%ld\n", (*p)->pid, 'J', jiffies);
			}
		}

/* this is the scheduler proper: */

	while (1) {
		c = -1;
		next = 0;
		i = NR_TASKS;
		p = &task[NR_TASKS];
		while (--i) {
			if (!*--p)
				continue;
			if ((*p)->state == TASK_RUNNING && (*p)->counter > c)
				c = (*p)->counter, next = i;
		}
		if (c) break;
		for(p = &LAST_TASK ; p > &FIRST_TASK ; --p)
			if (*p)
				(*p)->counter = ((*p)->counter >> 1) +
						(*p)->priority;
	}
	if(task[next]->pid != current->pid){
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'W', jiffies);
		fprintk(3, "%ld\t%c\t%ld\n", task[next]->pid, 'R', jiffies);
	}
		
	switch_to(next);
}

int sys_pause(void)
{
	current->state = TASK_INTERRUPTIBLE;
	schedule();
	return 0;
}

void sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp = *p;
	*p = current;
	current->state = TASK_UNINTERRUPTIBLE;
	schedule();
	if (tmp){
		tmp->state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
	}
		
}

void interruptible_sleep_on(struct task_struct **p)
{
	struct task_struct *tmp;

	if (!p)
		return;
	if (current == &(init_task.task))
		panic("task[0] trying to sleep");
	tmp=*p;
	*p=current;
repeat:	current->state = TASK_INTERRUPTIBLE;
	schedule();
	if (*p && *p != current) {
		(**p).state=0;
		fprintk(3, "%ld\t%c\t%ld\n", (**p).pid, 'J', jiffies);
		goto repeat;
	}
	*p=NULL;
	if (tmp){
		tmp->state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
	}
		
}

void wake_up(struct task_struct **p)
{
	if (p && *p) {
		(**p).state=0;
		fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'J', jiffies);
		*p=NULL;
	}
}
```

## exit.c
```c
int do_exit(long code)
{
	int i;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
	for (i=0 ; i<NR_TASKS ; i++)
		if (task[i] && task[i]->father == current->pid) {
			task[i]->father = 1;
			if (task[i]->state == TASK_ZOMBIE)
				/* assumption task[1] is always init */
				(void) send_sig(SIGCHLD, task[1], 1);
		}
	for (i=0 ; i<NR_OPEN ; i++)
		if (current->filp[i])
			sys_close(i);
	iput(current->pwd);
	current->pwd=NULL;
	iput(current->root);
	current->root=NULL;
	iput(current->executable);
	current->executable=NULL;
	if (current->leader && current->tty >= 0)
		tty_table[current->tty].pgrp = 0;
	if (last_task_used_math == current)
		last_task_used_math = NULL;
	if (current->leader)
		kill_session();
	current->state = TASK_ZOMBIE;
	current->exit_code = code;
	// before father wakes up, children exits
	fprintk(3, "%ld\t%c\t%ld\n", current->pid, 'E', jiffies);
	tell_father(current->father);
	schedule();
	return (-1);	/* just to suppress warnings */
}
```
## fock.c
```c
int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
		long ebx,long ecx,long edx,
		long fs,long es,long ds,
		long eip,long cs,long eflags,long esp,long ss)
{
	struct task_struct *p;
	int i;
	struct file *f;

	p = (struct task_struct *) get_free_page();
	if (!p)
		return -EAGAIN;
	task[nr] = p;
	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
	p->state = TASK_UNINTERRUPTIBLE;
	p->pid = last_pid;
	p->father = current->pid;
	p->counter = p->priority;
	p->signal = 0;
	p->alarm = 0;
	p->leader = 0;		/* process leadership doesn't inherit */
	p->utime = p->stime = 0;
	p->cutime = p->cstime = 0;
	p->start_time = jiffies;
	p->tss.back_link = 0;
	p->tss.esp0 = PAGE_SIZE + (long) p;
	p->tss.ss0 = 0x10;
	p->tss.eip = eip;
	p->tss.eflags = eflags;
	p->tss.eax = 0;
	p->tss.ecx = ecx;
	p->tss.edx = edx;
	p->tss.ebx = ebx;
	p->tss.esp = esp;
	p->tss.ebp = ebp;
	p->tss.esi = esi;
	p->tss.edi = edi;
	p->tss.es = es & 0xffff;
	p->tss.cs = cs & 0xffff;
	p->tss.ss = ss & 0xffff;
	p->tss.ds = ds & 0xffff;
	p->tss.fs = fs & 0xffff;
	p->tss.gs = gs & 0xffff;
	p->tss.ldt = _LDT(nr);
	p->tss.trace_bitmap = 0x80000000;
	if (last_task_used_math == current)
		__asm__("clts ; fnsave %0"::"m" (p->tss.i387));
	if (copy_mem(nr,p)) {
		task[nr] = NULL;
		free_page((long) p);
		return -EAGAIN;
	}
	for (i=0; i<NR_OPEN;i++)
		if ((f=p->filp[i]))
			f->f_count++;
	if (current->pwd)
		current->pwd->i_count++;
	if (current->root)
		current->root->i_count++;
	if (current->executable)
		current->executable->i_count++;
	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
	p->state = TASK_RUNNING;	/* do this last, just in case */
	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'N', jiffies);
	fprintk(3, "%ld\t%c\t%ld\n", p->pid, 'J', jiffies);
	return last_pid;
}
```

# 编写测试程序process.c
```c
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <sys/times.h>
#include <sys/wait.h>


#define HZ	100

void cpuio_bound(int last, int cpu_time, int io_time);

void children();

void children(){
	cpuio_bound(10, 1, 1);
}

int main(int argc, char * argv[])
{
	int sta;
	pid_t wpid;
	int cnt = 2;
	pid_t pid;
	int i;

	printf("father: %d\n", getpid());
	fflush(stdout);

	for(i = 0; i < cnt; i++){
		if(pid = fork()){
			printf("children%d: %d\n", i, pid);
			fflush(stdout);
		}else{
			children();
			break;
		}
	}

	/* wait for all children */
	while((wpid = wait(&sta)) > 0){
		printf("children%d exit\n", wpid);
		fflush(stdout);
	}
	
	return 0;
}

/*
 * 此函数按照参数占用CPU和I/O时间
 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，>=0是必须的
 * cpu_time: 一次连续占用CPU的时间，>=0是必须的
 * io_time: 一次I/O消耗的时间，>=0是必须的
 * 如果last > cpu_time + io_time，则往复多次占用CPU和I/O
 * 所有时间的单位为秒
 */
void cpuio_bound(int last, int cpu_time, int io_time)
{
	struct tms start_time, current_time;
	clock_t utime, stime;
	int sleep_time;

	while (last > 0)
	{
		/* CPU Burst */
		times(&start_time);
		/* 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个
		 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime
		 * 加上很合理。*/
		do
		{
			times(&current_time);
			utime = current_time.tms_utime - start_time.tms_utime;
			stime = current_time.tms_stime - start_time.tms_stime;
		} while ( ( (utime + stime) / HZ )  < cpu_time );
		last -= cpu_time;

		if (last <= 0 )
			break;

		/* IO Burst */
		/* 用sleep(1)模拟1秒钟的I/O操作 */
		sleep_time=0;
		while (sleep_time < io_time)
		{
			sleep(1);
			sleep_time++;
		}
		last -= sleep_time;
	}
}

```

# 实验结果
```
1	N	48
1	J	48
0	W	48
1	R	48
2	N	49
2	J	49
1	W	49
2	R	49
3	N	64
3	J	64
2	W	64
3	R	64
3	W	68
2	R	68
2	E	73
1	J	73
1	R	73
4	N	74
4	J	74
1	W	74
4	R	74
5	N	106
5	J	106
4	W	107
5	R	107
5	J	109
5	E	109
4	R	109
4	W	115
0	R	115
0	J	508
0	W	508
4	R	508
4	W	508
0	R	508
0	J	598
0	W	598
4	R	598
4	W	598
0	R	598
0	J	612
0	W	612
4	R	612
4	W	612
0	R	612
0	J	688
0	W	688
4	R	688
4	W	694
0	R	694
0	J	707
0	W	707
4	R	707
4	W	707
0	R	707
0	J	898
0	W	898
4	R	898
6	N	899
6	J	899
4	W	900
6	R	900
7	N	903
7	J	903
8	N	903
8	J	903
6	W	904
8	R	904
8	W	919
7	R	919
7	W	934
8	R	934
8	W	949
7	R	949
7	W	964
8	R	964
8	W	979
7	R	979
7	W	994
8	R	994
8	W	1009
7	R	1009
7	W	1024
8	R	1024
8	W	1039
7	R	1039
7	W	1054
8	R	1054
8	W	1069
7	R	1069
7	W	1084
8	R	1084
8	W	1094
7	R	1094
7	W	1104
0	R	1104
8	J	1195
0	W	1195
8	R	1195
7	J	1215
8	W	1215
7	R	1215
7	W	1232
8	R	1232
8	W	1247
7	R	1247
7	W	1262
8	R	1262
8	W	1277
7	R	1277
7	W	1292
8	R	1292
8	W	1307
7	R	1307
7	W	1322
8	R	1322
8	W	1337
7	R	1337
7	W	1352
8	R	1352
8	W	1367
7	R	1367
7	W	1382
8	R	1382
8	W	1387
7	R	1387
7	W	1395
0	R	1395
8	J	1488
0	W	1488
8	R	1488
7	J	1498
8	W	1498
7	R	1498
7	W	1505
8	R	1505
8	W	1520
7	R	1520
7	W	1535
8	R	1535
8	W	1550
7	R	1550
7	W	1565
8	R	1565
8	W	1580
7	R	1580
7	W	1595
8	R	1595
8	W	1610
7	R	1610
7	W	1625
8	R	1625
8	W	1640
7	R	1640
7	W	1655
8	R	1655
8	W	1670
7	R	1670
7	W	1685
8	R	1685
8	W	1685
7	R	1685
7	W	1688
0	R	1688
8	J	1786
0	W	1786
8	R	1786
7	J	1801
8	W	1801
7	R	1801
7	W	1813
8	R	1813
8	W	1828
7	R	1828
7	W	1843
8	R	1843
8	W	1858
7	R	1858
7	W	1873
8	R	1873
8	W	1888
7	R	1888
7	W	1903
8	R	1903
8	W	1918
7	R	1918
7	W	1933
8	R	1933
8	W	1948
7	R	1948
7	W	1963
8	R	1963
8	W	1973
7	R	1973
7	W	1986
0	R	1986
8	J	2074
0	W	2074
8	R	2074
7	J	2094
8	W	2094
7	R	2094
7	W	2110
8	R	2110
8	W	2125
7	R	2125
7	W	2140
8	R	2140
8	W	2155
7	R	2155
7	W	2170
8	R	2170
8	W	2185
7	R	2185
7	W	2200
8	R	2200
8	W	2215
7	R	2215
7	W	2230
8	R	2230
8	W	2245
7	R	2245
7	W	2260
8	R	2260
8	W	2265
7	R	2265
7	W	2274
0	R	2274
8	J	2366
0	W	2366
8	R	2366
8	E	2366
6	J	2366
6	R	2366
6	W	2366
0	R	2366
7	J	2375
0	W	2375
7	R	2375
7	E	2375
6	J	2375
6	R	2375
6	E	2376
4	J	2376
4	R	2376
9	N	2377
9	J	2377
4	W	2377
9	R	2377
9	J	2379
9	E	2380
4	R	2380
4	W	2380
0	R	2380
0	J	2668
0	W	2668
4	R	2668
4	W	2668
0	R	2668
0	J	2698
0	W	2698
4	R	2698
4	W	2698
0	R	2698
0	J	2728
0	W	2728
4	R	2728
4	W	2728
0	R	2728
0	J	2788
0	W	2788
4	R	2788
4	W	2788
0	R	2788
0	J	2818
0	W	2818
4	R	2818
4	W	2818
0	R	2818
0	J	2835
0	W	2835
4	R	2835
4	W	2835
0	R	2835
0	J	2878
0	W	2878
4	R	2878
10	N	2880
10	J	2880
4	W	2880
10	R	2880
```

