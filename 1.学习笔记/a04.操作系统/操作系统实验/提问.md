## 问题1：as86汇编语法，寄存器寻址报错
背景：最近正在做哈工大那门操作系统实验项目，修改linux0.11中setup.s的代码时，使用`mov bp, [bx+si]`类似的语法，但是编译总是报错![[registerusedasidentifier.png]]
尝试过`mov bp, [ebx+esi]`, `mov bp, [bx]`, `mov bp, ds:[bx]`均报错
主机版本：ubuntu 22.04.4
编译器版本：as86 0.16.17

回答：
as86有个参数-a，使用后，需要吧`[]`改成`()`
![[as86参数a.png]]


## 问题2：c语言，函数参数值传递错误
背景：最近正在学习linux0.11源码，并加以调试，在实验中，需要在进程退出时打印进程消息，于是在`/kernel/printk.c`中添加frpintk函数，如下所示：
```c
// static char logbuf[1024];
int fprintk(int fd)
{
	printk("--------------------------------------\n");
	printk("fprintk called with fd: %d\n", fd);  // 调试信息
	// va_list args;
	// int count;
	// va_start(args, fmt);
	// count = vsprintf(logbuf, fmt, args);
	// va_end(args);
	// printk("fprintk: formatted string: %s\n", logbuf);  // 调试信息
	// if (fd == 3) {
	// 	count = sys_write(fd, logbuf, count);
	// 	printk("fprintk: written %d bytes to fd %d\n", count, fd);  // 调试信息
	// }
	printk("--------------------------------------\n");
	// return count;
	return 0;
}
```
接着在`/kernel/exit.c`的`do_exit()`函数中添加该函数调用：
```c
int fd = 3;
......
printk("exit fd: %d\n", fd);
// fprintk(fd, "%ld\t%c\t%ld\n", current->pid, 'E', jiffies);
fprintk(fd);
...
```
实际实验中，发现打印出来的fd不是3，而是一个很奇怪的值，就不知道是为什么。
![[函数值传递错误.png]]
回答：
修改编译器优化参数-O为-O0，禁止编译器优化（只针对exit和printk两个文件）
```makefile
kernel.o: $(OBJS)
	$(LD) -m elf_i386 -r -o kernel.o $(OBJS)
	sync

exit.o: exit.c
	$(CC) $(CFLAGS) -O0 -c -o exit.o exit.c

printk.o: printk.c
	$(CC) $(CFLAGS) -O0 -c -o printk.o printk.c

.c.s:
	$(CC) $(CFLAGS) \
	-S -o $*.s $<
.s.o:
	$(AS) -o $*.o $<
.c.o:
	$(CC) $(CFLAGS) \
	-c -o $*.o $<
```

## 问题3: 嵌入汇编的坑
下面两段代码，区别仅仅在于将两段嵌入汇编放在
```c
static char logbuf[1024];
int fprintk(int fd, const char *fmt, ...)
{
	va_list args;
	int count;
	struct file * file;
	struct m_inode * inode;
	va_start(args, fmt);
	count = vsprintf(logbuf, fmt, args);
	va_end(args);
	if (fd == 3) {
		// get file by 1 process
		if (!(file=task[0]->filp[fd]))    /* 从进程0的文件描述符表中得到文件句柄 */
            return 0;
		inode = file->f_inode;
		__asm__("push %%fs\n\t"
				"push %%ds\n\t"
				"pop %%fs\n\t"
				::);
		__asm__("pushl %0\n\t"
				"pushl $logbuf\n\t"
				"pushl %1\n\t"
				"pushl %2\n\t"
				"call file_write\n\t"
				"addl $12,%%esp\n\t"
				"popl %0\n\t"
				"pop %%fs\n\t"
				::"r"(count), "r"(file), "r"(inode):"ax","cx","dx");
		printk("logbuf: %s\n", logbuf);
		printk("write %d bytes\n", count);
	}
	return count;
}
```

```c
static char logbuf[1024];
int fprintk(int fd, const char *fmt, ...)
{
	va_list args;
	int count;
	struct file * file;
	struct m_inode * inode;
	va_start(args, fmt);
	count = vsprintf(logbuf, fmt, args);
	va_end(args);
	if (fd == 3) {
		// get file by 1 process
		if (!(file=task[0]->filp[fd]))    /* 从进程0的文件描述符表中得到文件句柄 */
            return 0;
		inode = file->f_inode;
		__asm__("push %%fs\n\t"
				"push %%ds\n\t"
				"pop %%fs\n\t"
				"pushl %0\n\t"
				"pushl $logbuf\n\t"
				"pushl %1\n\t"
				"pushl %2\n\t"
				"call file_write\n\t"
				"addl $12,%%esp\n\t"
				"popl %0\n\t"
				"pop %%fs\n\t"
				::"r"(count), "r"(file), "r"(inode):"ax","cx","dx");
		printk("logbuf: %s\n", logbuf);
		printk("write %d bytes\n", count);
	}
	return count;
}
```