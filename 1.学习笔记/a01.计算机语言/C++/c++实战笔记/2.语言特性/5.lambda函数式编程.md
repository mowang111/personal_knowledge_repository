在 C/C++ 里，所有的函数都是全局的，没有生存周期的概念（static、名字空间的作用很弱，只是简单限制了应用范围，避免名字冲突）。而且函数也都是平级的，不能在函数里再定义函数，也就是**不允许定义嵌套函数、函数套函数**。

```c++
void my_square(int x)           // 定义一个函数
{
    cout << x*x << endl;       // 函数的具体内容
}
auto pfunc = &my_square;       // 只能用指针去操作函数，指针不是函数
(*pfunc)(3);                    // 可以用*访问函数
pfunc(3);                       // 也可以直接调用函数指针
```

## lambda

C++11 引入的 lambda 表达式

```c++
auto func = [](int x)          // 定义一个lambda表达式
{   
    cout << x*x << endl;      // lambda表达式的具体内容
};  
func(3);                      // 调用lambda表达式
```

因为 lambda 表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“**就地**”定义函数，限制它的作用域和生命周期，实现函数的局部化。

C++ 里的 lambda 表达式除了可以像普通函数那样被调用，还有一个普通函数所不具备的特殊本领，就是可以“捕获”外部变量，在内部的代码里直接操作。

```c++
int n = 10;                     // 一个外部变量
auto func = [=](int x)          // lambda表达式，用“=”值捕获
{
    cout << x*n << endl;        // 直接操作外部变量
};
func(3);                    // 调用lambda表达式
```

lambda 表达式就是在其他语言中大名鼎鼎的“**闭包**”（closure），这让它真正超越了函数和函数对象。

它虽然在出现时被定义，但因为保存了定义时捕获的外部变量，就可以跳离定义点，把这段代码“打包”传递到其他地方去执行，而仅凭函数的入口参数是无法做到这一点的。

## 使用 lambda 的注意事项

### **1.lambda 的形式**

C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“**[]**”，术语叫“**lambda 引出符**”（lambda introducer）。

一定**要有良好的缩进格式**——特别是有嵌套定义的时候，尽量让人能够一眼就看出 lambda 表达式的开始和结束，必要的时候可以用注释来强调。

```c++
auto f2 = []()                 // 定义一个lambda表达式
{
    cout << "lambda f2" << endl;
    auto f3 = [](int x)         // 嵌套定义lambda表达式
    {
        return x*x;
    };// lambda f3              // 使用注释显式说明表达式结束
    cout << f3(10) << endl;
};  // lambda f2               // 使用注释显式说明表达式结束
```

在 C++ 里，每个 lambda 表达式都会有一个独特的类型，而这个类型只有编译器才知道，我们是无法直接写出来的，所以必须用 auto。

因为 lambda 表达式毕竟不是普通的变量，所以 C++ 也鼓励程序员**尽量“匿名”使用 lambda 表达式**。

```c++
vector<int> v = {3, 1, 8, 5, 0};     // 标准容器
cout << *find_if(begin(v), end(v),   // 标准库里的查找算法
            [](int x)                // 匿名lambda表达式，不需要auto赋值
            {
                return x >= 5;        // 用做算法的谓词判断条件 
            }                        // lambda表达式结束
        )
     << endl;                        // 语句执行完，lambda表达式就不存在了
```

### **2.lambda 的变量捕获**

+ “[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改；
+ “[&]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改；
+ 你也可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获，C++ 在这里给予了非常大的灵活性。

```c++
int x = 33;               // 一个外部变量
auto f1 = [=]()           // lambda表达式，用“=”按值捕获
{
    //x += 10;            // x只读，不允许修改
};
auto f2 = [&]()         // lambda表达式，用“&”按引用捕获
{
    x += 10;            // x是引用，可以修改
};
auto f3 = [=, &x]()       // lambda表达式，用“&”按引用捕获x，其他的按值捕获
{
    x += 20;              // x是引用，可以修改
};
```

### **3. 泛型的 lambda**

在 C++14 里，lambda 表达式又多了一项新本领，可以实现“**泛型化**”，相当于简化了的模板函数，具体语法还是利用了“多才多艺”的 auto：

```c++
auto f = [](const auto& x)        // 参数使用auto声明，泛型化
{
    return x + x;
};
cout << f(3) << endl;             // 参数类型是int
cout << f(0.618) << endl;         // 参数类型是double
string str = "matrix";
cout << f(str) << endl;          // 参数类型是string
```

![img](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/5ac283e096d87e582fed017597ba4e0d.jpg)