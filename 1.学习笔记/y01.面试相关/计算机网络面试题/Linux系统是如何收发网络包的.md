![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230310095023.png)



# Linux接收网络包的流程
当有网络包到达时，会通过DMA技术，将网络包写入到指定内存（Ring buffer）中，接着网卡向CPU发起硬件中断，当CPU收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。

硬件中断会做如下的事情：
+ 需要先【暂时屏蔽中断】，表示已经知道内存中有数据了，告诉网卡下次再收到数据表直接写入内存即可，不用再通知CPU了，这样可以提高效率，避免CPU不同被中断
+ 接着发起【软中断】，然后恢复刚才屏蔽的中断

软中断的处理：
内核中的ksoftirqd线程专门负责软中断的处理，当ksoftirqd内核线程收到软中断后，就会来轮询处理数据。
ksoftirqd线程会从Ring buffer中获取一个数据帧，用sk_buff表示，从而可以作为一个网络包交给协议栈进行逐层处理。

网络协议栈的处理：
首先，会进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议类型，比如时IPv4，还是IPv6，接着再去掉帧头和帧尾，然后交给网络层
到来网络层，则取出IP包，判断网络包的下一步走向，比如是交给上层处理还是转发出去。当确认这个网络包是要发送给本机后，就会从IP头里看看上层协议的类型是TCP还是UDP，接着去掉IP头，然后交给传输层。
传输层取出TCP头或UDP头，根据四元组【源IP、源端口、目的IP、目的端口】作为标识，找出对应的Socket，并把数据放到Socket的接收缓冲区。
最后，应用层程序调用Socket接口，将内核的Socket接收缓冲区的数据【拷贝】到应用层的缓冲区，然后唤醒用户进程

![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230310095656.png)

# Linux发送网络包的流程

首先，应用程序会调用Socket发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的Socket层，内核会申请一个内核态的sk_buff内存，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区。

接下来，网络协议栈从Socket发送缓冲区中取出sk_buff，并按照TCP/IP协议栈从上到下逐层处理。

如果使用的是TCP传输协议，就会先拷贝一个新的sk_buff副本，这是因为sk_buff后续在调用网络层，最后到达网卡发送完成的时候，这个sk_buff会被释放掉。而TCP协议支持丢失重传，在收到对方的ACK之前，这个sk_buff不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是sk_buff的一个拷贝，等收到ACK再真正删除。

接着，对sk_buff填充TCP头。（sk_buff可以表示各个层的数据包，在应用层数据包叫data，在TCP层称为segment，在IP层叫packet，在数据链路层称为frame）

然后交给网络层，网络层在这里会做的工作：选取路由（确认下一跳的IP）、填充IP头、netfilter过滤、对超过MTU大小的数据包进行分片。处理完这些工作后交给网络接口层处理。

网络接口层会通过ARP协议获得下一跳的MAC地址，然后对sk_buff填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。

这些工作准备好后，会触发【软中断】告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取sk_buff，将这个sk_buff挂到RingBuffer中，接着将sk_buff数据映射到网卡可访问的内存DMA区域，最后触发真实的发送。

当数据发送完成后，其实工作还没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放sk_buff内存和清理RingBuffer内存。

最后，当收到这个TCP报文的ACK应答时，传输层就会释放原始的sk_buff。


> 发送网络数据的时候，涉及几次内存拷贝操作？
> 1. 调用发送数据的系统调用的时候，内核会申请一个内核态的sk_buff内存，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区
> 2. 在使用TCP传输协议时，从传输层进入网络层的时候，每一个sk_buff都会被克隆一个新的副本出来。副本sk_buff会被送往网络层，等它发送完的时候就会释放掉，然后原始的sk_buff还保留在传输层，目的是为了实现TCP的可靠传输，等收到这个数据包的ACK时，才会释放原始的sk_buff。
> 3. 当IP层发现sk_buff大于MTU时才需要进行。会再申请额外的sk_buff，并将原来的sk_buff拷贝为多个小的sk_buff。