# HTTP工作原理
HTTP协议定义Web客户端如何从web服务器请求web页面，以及服务器如何把web页面传送给客户端。HTTP协议采用了请求/相应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，相应的内容包括协议的版本、成功或者错误代码、服务器信息、相应头部和相应数据。
以下是HTTP请求/响应的步骤：
1. 客户端连接到web服务器
	一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。
2. 发送HTTP请求
	通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由`请求行、请求头部、空行和请求数据`4部分组成。
3. 释放连接TCP连接
	若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
4. 客户端浏览器解析HTML内容
	客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。
在浏览器地址栏键入URL，按下回车之后会经历以下流程：
1. 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址。
2. 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接
3. 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；
4. 服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器
5. 释放TCP连接；
6. 浏览器解析html文本并显示内容

# HTTP报文格式
## 请求报文
HTTP协议以ASCII码传输，请求报文由请求行、请求头、（空行以及）消息体组成。
一个消息主体一定包含一个实体主体，通常情况下消息主体等于实体主体，实体主体也可能经过传输编码机制处理，在通信时按照某种编码方式传输。
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230218204050.png)

## 响应报文
HTTP响应报文也由三部分组成：状态行、响应头、（空行以及）消息体
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230218204150.png)

### HTTP分块传输编码
在HTTP通信过程中，请求的编码实体资源尚未全部传输之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。它通过在Header里两个参数实现的，客户端请求时对应的时Range,服务端响应时对应的时Content-Range。Range用于请求头中，指定第一个字节的位置和最后一个字节的位置。Content-Range用于响应头中，在发出带Range的请求后，服务器会在Content-Range头部返回当前接受的范围和文件总大小。

### HTTP常见字段
+ Host字段：客户端指定服务器的域名，可以将请求发往【同一台】服务器上的不同网站
+ Content-Length字段：服务器返回数据的长度
+ Content-Type字段：服务器回应客户端的数据格式。客户端请求时，可以用Accept字段声明自己可以接受哪些数据格式
+ Content-Encoding字段：服务器返回数据使用的压缩格式。客户端在请求时，用Accpet-Enoding字段说明自己可以接受哪些压缩方法
+ Connection字段：最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。HTTP/1.1版本的默认连接都是持久连接，但为了兼容老版本的HTTP，需要指定Connect首部字段值为Keep-Alive。

# HTTP常见的状态码有哪些？
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230214121941.png)

# HTTP的Keep-Alive和TCP的Keepalive的区别？
HTTP的Keep-Alive也叫HTTP长连接，该功能是由【应用】程序实现的，可以使得用同一个TCP连接来发送和接收多个HTTP请求/应答，减少了HTTP短连接带来的多次TCP连接建立和释放的开销。
TCP的Keepalive也叫TCP保活机制，该功能是由【内核】实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接释放还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接。

# Cookie和Session区别
两者都是用来跟踪浏览器用户身份的会话方式
Cookie：存在浏览器里，可以设置过期时间，每次访问服务器时，浏览器会自动在header中携带cookie。如果浏览器禁用了cookie，可以使用URL地址重写机制，将信息保存在URL里。
Session：存在服务端，由服务器维护，服务端设置过期时间。如果用户长时间不和服务器交互（比如30min），那么session就会被销毁，交互则会刷新session。浏览器的cookie中只保存一个sessionId,所有其他信息均保存在服务端，由sessionId标识

## Session实现原理
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230218213740.png)
Manager: 充当一个session管理器的角色，主要存储一些配置信息，比如session的存活时间，cookie的名字等等。而所有的session存在Manager内部的一个Provider中。所以Manager会把sid(sessionID)传递给Provider，让它去找这个ID对应的具体是哪个session。
Provider就是一个容器，最常见的就是一个散列表，将每个sid和对应的session一一映射起来。收到Manager传递的sid之后，它就找到sid对应的session结构，也就是Session结构，然后返回它。
Session中存储着用户的具体信息，由Handler函数中的逻辑拿出这些信息，生成该用户的HTML网页，返回给客户端

### 既然session就是键值对，为啥不直接用哈希表？
1. 可以存储一些辅助数据，比如sid，访问次数，过期时间或者最后一次的访问时间，这样便于实现向LRU、LFU这样的算法
2. 可以有不同的存储方式，比如存入缓存数据库Redis，或者存入MySQL等。如果用编程语言内置的哈希表，那么session数据就是存储在内存中，如果数据量大，很容易造成程序崩溃，而且一旦程序结束，所有session数据都会丢失。

### Provider为啥要抽象出来？
上图的Provider就是一个散列表，保存sid到Session的映射，但是实际中肯定会更加复杂。比如时不时需要删除一些session，除了设置存活时间之外，还可以采用一些其他策略，比如LRU缓存淘汰算法，这样就需要Provider内部使用哈希链表这种数据结构来存储session。

### Manager为啥要抽象出来？
大部分具体工作都委托给了Session和Provider承担了，Manager主要就是一个参数集合，比如session的存活时间，清理过期session的策略，以及session的可用存储方式。Manager屏蔽了操作的具体细节，可以通过Manager灵活配置session机制

# HTTP请求方法
主要是三种方法：GET、POST和HEAD方法
+ GET：请求指定的页面信息，并返回实体主体
+ HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
+ POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
+ PUT: 从客户端向服务器传送的数据取代指定的文档的内容。
+ PATCH：替换目标资源的部分内容
+ DELETE：删除指定资源
+ OPTIONS: 可以检测服务器支持哪些HTTP方法
+ TRACE：执行一个消息环回测试，返回到服务端的路径。客户端请求连接到目标服务器时可能回哦那个给代中转，通过TRACE方法可以查询发送出去的请求的一系列操作
### 幂等的
一个HTTP方法时幂等的，指的时同样的请求执行一次与执行多次的效果是一样的，换句话说，幂等方法不应该具有副作用。
+ 常见的幂等方法：GET，HEAD，PUT，DELETE，OPTIONS
+ 常见的非幂等方法：POST
### 安全的
一个HTTP方法是安全的，指这是一个对服务器只读操作的方法，不会修改服务器数据
+ 常见的安全方法：GET，HEAD，OPTIONS
+ 常见的不安全方法：PUT，DELETE，POST
## 可缓存的
GET、HEAD


# GET和POST有什么区别？
GET的语义是从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。GET请求的参数位置一般是写在URL中，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符，而且浏览器会对URL的长度有限制（HTTP协议本身对URL长度并没有做任何规定）
POST的语义是根据请求负荷（报文body）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST请求携带数据的位置一般是写在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好，而且浏览器不会对body大小做限制。
+ 作用上：GET获取服务器资源，可被缓存，POST添加/修改服务器资源，不能被缓存
+ 幂等/安全性：GET是幂等安全的 ，POST是非幂等不安全的
+ 参数位置：GET暴露在URL链接中，POST在消息体中
+ 参数长度：GET由浏览器限制，POST无限制

# HTTP缓存实现方式
## 强制缓存
强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。
强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：
-   `Cache-Control`， 是一个相对时间；
-   `Expires`，是一个绝对时间；
如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 。

具体实现流程如下：
1. 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在响应头部加上Cache-Control字段，其中设置了过期时间；
2. 浏览器再次请求访问服务器中的该资源时，回通过请求资源的时间与Cache-Control中设置的过期时间来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器；
3. 服务器再次收到请求后，会更新响应头部的Cache-Control;

## 协商缓存
当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。

协商缓存可以基于两种头部来实现
+ 第一种：请求头部中的If-Modified-Since字段与响应头部中Last-Modified字段实现。Last-Modified标示这个响应资源的最后修改时间，If-Modified-Since告诉服务器对比下资源的最后修改时间，然后决定是否走缓存
+ 第二种：请求头部中If-None-Match字段与响应头部中的ETag字段（唯一标识响应资源）。其中请求头部中的If-None-Match字段表示当资源过期时，浏览器发现响应头里有Etag,则再次向服务器发起请求时，会将请求头If-None-Match值设置为Etag的值。服务器收到请求后进行比对，如果资源没有变化返回304，资源变化返回200；
第一种实现是基于时间实现的，第二种实现是基于一个唯一标识实现的，相对来说后者更加准确地判断文件内容是否被修改，避免时间篡改导致的不可靠问题。
注意：只有在未能命中强制缓存时，才能使用协商缓存。

# HTTP协议版本
![image.png](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/20230218215342.png)

## HTTP/1.1
简答，灵活和易于扩展、应用广泛和跨平台
HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充
同时HTTP由于是工作在应用层，它下层可以随意变化
+ HTTPS就是在HTTP与TCP层之间增加了SSL/TLS安全传输层；
+ HTTP/1.1和HTTP2.0传输协议用的是TCP协议，而到了HTTP/3.0 传输层协议改用了UDP协议
HTTP协议有优缺点一体的双刃剑，分别是【无状态、明文传输】，不安全
性能：长连接、管道网络传输（有这个功能，没有被使用）->队头阻塞

### HTTP/1.1相比HTTP/1.0性能上的改进
+ 使用长连接的方式改善了HTTP/1.0短连接造成的性能开销，不过长连接会占用服务器资源
+ 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间
### 性能瓶颈
+ 请求/响应头部未经压缩发送，首部信息越多延迟越大，且每次互相发送相同的首部造成的浪费较多
+ 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是队头阻塞；
+ 没有请求优先级控制；
+ 请求只能从客户端开始，服务器只能被动响应
### 如何优化？
+ 尽量避免发送HTTP请求：尽量使用缓存处理。
+ 尽量减少请求次数：利用代理服务器等减少重定向请求次数；合并请求资源；延迟发送请求。
+ 减少响应的数据大小：通过有损或无损压缩对响应的资源进行压缩
## HTTP/2.0
HTTP/2协议是基于HTTPS的
改进点：
1. Header压缩：头部的编码通过【静态表（保存常用字段编码并固定在协议中）、动态表（动态添加静态表中没有的字段编码）、Huffman编码】共同完成。
2. 二进制分帧：HTTP/1.x采用文本格式传输数据。HTTP/2.0将所有传输信息分割为若干个帧，采用二进制格式进行编码。具体实现上，是在应用层（HTTP）和传输层（TCP）之间增加一个二进制分帧层。每个请求对应一个流，有个唯一的标识符。请求报文会被拆分为一个或多个帧（帧头+消息负载），每个帧有序列号，以及自己所属流的标识符，接收端自行合并。同时，二进制分帧采用的流传输也为多路复用提供了基础。
3. 多路复用：每个请求或响应的数据包称为一个数据流，每个数据流都有唯一的编号，因此不同流的帧可以乱序发送（即可以并发不同的流）。因为每个帧的头部会携带流编号信息，所以接收端可以通过流编号有序拼接HTTP消息。客户端和服务器双方都可以建立流，其中客户端建立的流编号必须是奇数号，而服务器建立的流编号必须是偶数号。客户端还可以指定数据流的优先级。
4. 服务端推送：服务端会根据客户端的请求，提前推送额外的资源给客户端，可以减轻数据传输的冗余步骤，同时加快页面响应速度，提升用户体验。比如在发送页面HTML时主动推送其它CSS/JS资源，而不用等到浏览器解析到相应位置，发起请求再相应。
HTTP/2.0缺陷：
+ HTTP队头阻塞。HTTP/2是基于TCP协议来传输数据的，TCP是字节流协议，TCP层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给HTTP应用，那么当【前1个字节数据】没有到达时，后受到的字节数据只能存放再内核缓冲区里，只有等到这1个字节数据到达时，HTTP/2应用层才能从内核中拿到数据，这就是HTTP/2队头阻塞问题。所以，一旦发送了丢包现象，就会触发TCP的重传机制，这样在一个TCP连接中的所有的HTTP请求都必须等待这个丢了的包被重传回来。
+ 慢启动降低效率。TCP由于具有【拥塞控制】的特性，所以刚建立连接的TCP会有个【慢启动】的过程，它会对TCP连接产生“减速”效果。
+ 网络切换重连。一个TCP连接是由四元组（源IP地址，源端口，目标IP地址，目标端口）确定的，这意味着如果IP地址或者端口变动了，就会导致需要TCP于TLS重新握手，不利于移动设备切换网络的场景，比如4G网络环境切换成WIFI。
## HTTP/3.0/QUIC
HTTP/3优化：
+ 改进头部压缩算法。HTTP/3中的QPACK也采用了静态表、动态表以及Huffman编码。HTTP/2和HTTP/3的动态表编解码方式不同，QUIC会有两个特殊的单向流，这两个特殊的单向流是用来同步双方的动态表，编码方收到解码方更新确认的通知后，才使用动态表编码HTTP头部
+ 更换传输协议。HTTP/2虽然通过多个请求复用一个TCP连接解决了HTTP的队头阻塞，但是一旦发生丢包，就会阻塞住所有的HTTP请求，这属于TCP层队头阻塞。所以HTTP/3把HTTP下层的TCP协议改成了UDP，基于UDP的QUIC协议可以实现类似TCP的可靠传输

QUIC实现了两种级别的流量控制，分别为Stream和Connection两种级别：
+ Stream流量控制：每个HTTP请求对应一个流，每个Stream都有独立的滑动窗口，所以每个Stream都可以做流量控制，防止单个Stream占用连接的全部接收缓冲。
+ Connection流量控制：限制连接中所有Stream加起来的总字节数，防止发送方超过连接的缓冲容量。

QUIC有以下3个特点：
+ 无队头阻塞：当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞的问题。而HTTP/2只要某个流中的数据包丢失了，其他流也会受到影响。
+ 更快的建立连接：对于HTTPS和HTTP/2协议，TCP和TLS时分层的，需要分批次来握手，先TCP握手，再TLS握手。HTTP/3在传输数据前虽然需要QUIC协议握手，这个握手过程只需要1RTT，握手的目的是为了确认双方的【连接ID】,连接迁移就是基于连接ID实现的。不过QUIC协议并不是与TLS分层，其内部包含了TLS，再加上QUIC使用的是TLS/1.3，因此仅需1个RTT就可以【同时】完成建立连接与密钥协商。
+ 连接迁移：基于TCP传输协议的HTTP协议，由于是通过四元组（源IP，源端口，目的IP、目的端口）确定一条TCP连接，那么当移动设备的网络从4G切换到WIFI时，意味着IP地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程包含TCP三次握手和TLS四次握手的时延，以及TCP慢启动的减速过程，给用户的感觉时网络突然卡顿，因此连接的迁移成本很高。
	+ 而QUIC协议没有用四元组的方式绑定连接，而是通过连接ID来标记通信的两个端点，客户端和服务器可以各自选择一组ID来标记自己，因此即使移动设备的网络IP地址变化了，只要仍保有上下文信息（比如连接ID、TLS密钥等），就可以“无缝”地复用原连接。

# HTTPS

## HTTPS加密过程
1.  客户端请求服务器获取证书公钥
2.  客户端(SSL/TLS)解析证书（无效会弹出警告）
3.  生成随机值
4.  用公钥加密随机值生成密钥
5.  客户端将秘钥发送给服务器
6.  服务端用私钥解密秘钥得到随机值 （4.5.6 非对称加密过程）
7.  将信息和随机值混合在一起进行对称加密
8.  将加密的内容发送给客户端
9.  客户端用密钥解密信息


## HTTPS和HTTP的区别
-   安全性：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
-   连接步骤：HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
-   端口号：两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
-   数字证书：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

数字签名：发送端将消息使用hash函数生成摘要，并使用私钥加密后得到“数字签名”，并将其附在消息之后。接收端使用公钥对“数字签名”解密，确认发送端身份，之后对消息使用hash函数处理并与接收到的摘要对比，确认消息是否被修改

数字证书：数字中心CA使用私钥对用户的公钥和相关信息一起加密，生成“数字证书”。发送端在发送时除了需要数字签名，还需要附上数字证书。接收端使用CA公钥解开数字证书，拿到用户的公钥，则可证明该数字签名时真实发送端发送的。

## SSL/TLS
SST/TLS协议的基本思路是次啊用公钥加密法，也就说，客户端先向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
作用：
1. 所有的信息都是加密传播，第三方无法窃听
2. 具有校验机制，一旦被篡改，通信双方会立刻发现
3. 配备身份证书，防止身份被冒充

### 如何保证公钥不被篡改？
将公钥放在数字证书中，只要证书是可信的，公钥就是可信的。

### TCP和HTTPS握手顺序
【HTTPS是先进行TCP三次握手，再进行TLSv1.2四次握手】，而【HTTPS中TLS握手的过程可以同时进行三次握手】，但是需要满足下面三个条件：
1. 客户端和服务端已经完成过一次通信
2. TLS版本是1.3（TLSv1.3会话恢复机制，在重连TLSv1.3只需要0-RTT）;
3. 客户端和服务端都开启了TCP Fast Open功能（第一次通信服务端设置cookie选项，之后客户端保存并在后续再次连接时使用，可传递cookie建立连接并传输数据）

## RSA密钥交换算法
第一次握手：客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息：
1. 支持的协议版本，比如TLS 1.0版
2. 一个客户端生成的随机数，稍后用于生成“对话密钥”
3. 支持加密的方法，比如RSA公钥加密
4. 支持的压缩方法

第二次握手：服务器回应（SeverHello）
服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。
1. 确认使用的加密通信协议版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
2. 服务器生成的随机数，稍后用户生成“对话密钥”。
3. 确认使用的加密方法
4. 服务器证书
除了上面的信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”

第三次握手：客户端回应
客户端收到服务器回应后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。
1. 一个随机数。该随机数用服务器公钥加密，防止被窃听。
2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验
此时客户端和服务器就同时有了三个随机数，接着双方就用实现商定的加密方法，各自生成本次会话所用的同一把“会话密钥”，此外，如果前一步服务器要求客户端证书，客户端会在这一步发送证书及相关信息。

第四次握手：服务器的最后回应
服务器收到客户端的第三个随机数Pre-master key之后，计算生成本次会话所用的“会话密钥”。然后，向客户端最后发送下面的信息。
1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用“会话密钥”加密内容

### 使用RSA密钥协商算法的最大问题是不支持前向保密
因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的时公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有TLS通信密文都会被破解。为了解决这一问题，后面就出现独立ECDHE密钥协商算法，现在大多数网站使用的正是ECDHE密钥协商算法。

## ECDHE密钥交换算法
ECDHE密钥协商算法是DH算法演进过来的，DH算法是非对称加密算法，因此它可以用于密钥交换，该算法的核心数学思想是离散数学

RSA和ECDHE握手过程的区别
+ RSA密钥协商算法不支持前向保密，ECDHE密钥协商算法支持前向保密
+ 使用了RSA密钥协商算法，TLS完成四次握手后，才能进行应用数据传输，而对于ECDHE算法，客户端可以不用等服务端的最后一次TLS握手，就可以提前发出加密的HTTP数据，节省了一个消息的往返时间

