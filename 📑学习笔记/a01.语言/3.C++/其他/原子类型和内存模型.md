## 引言
探究这个问题的原因是来自一道美团面试题，针对单例模式的日志类，多线程情况下如何保证每个时刻只有一个线程操作日志文件？我当时回答加锁，但是加锁的开销很大，有没有无锁的方法，然后就找到了c++11的automic类型和内存模型的使用。

# C++11引入 的多线程特性
C++98/03标准中，并没有多线程相关特性供大家使用，C++11标准到来之前，我们不得不借助两种方法进行多线程开发：一是使用编译器厂商对C++语言的拓展进行多线程开发工作——POSIX Pthread、Windows API；二是借助Boost,ACE等库。但是缺乏统一的标准，缺乏线程感知的内存模型(thread-aware memory model), 意味着想要借助于处理器硬件知识极限压榨程序性能，和想要编写跨平台的多线程程序，都困难不小。

C++11标准中，相当大的变化就是引入了多线程的支持，使得C/C++进行线程编程时，不必依赖第三方库和标准。

而C++11对多线程支持中，最重要的一部分就是在原子操作中引入了原子类型的概念

## 原子操作？
原子操作，就是多线程程序中“最小化且不可并行化的”操作。
对于多个线程共享一个资源而言，就意味着互斥访问，一般来说就是加锁操作。
C++11标准从不同的视角看待这个问题：需要同步的总是资源/数据，而不是代码。因此C++11对数据进行了更为良好的抽象，引入"原子数据类型"/atomic类型，以达到对开发者掩盖互斥锁、临界区的目的。

**C++11 对常见的原子操作进行了抽象，定义出统一的接口，并根据编译选项/环境产生平台相关的实现。新标准将原子操作定义为atomic模板类的成员函数，囊括了绝大多数典型的操作——读、写、比较、交换等。**

# 内存模型

![[内存模型]]
**弱顺序的内存模型的好处在哪里？可以进一步挖掘指令中的并行性，提高指令执行的性能。**

# 参考文档
[C++11 - atomic类型和内存模型](https://zhuanlan.zhihu.com/p/107092432) 