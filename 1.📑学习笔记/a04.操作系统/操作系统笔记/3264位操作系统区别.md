---
title: 32位操作系统和64位操作系统区别
date: {{ date }}
top: false
cover: false
password:
toc: true
mathjax: true
summary:
tags: 
- 操作系统
categories: []
---

# 32位操作系统和64位操作系统区别

操作系统只是硬件和应用软件中间的一个平台。

32位操作系统针对的32位的CPU设计。
64位操作系统针对的64位的CPU设计。

我们的CPU从原来的8位，16位，到现在的32位和64位。

cpu处理计算的时候“数据”和“指令”是不同对待的。

8位的CPU,一次只能处理一个8位的“数据”或者一个8位的"指令"。比如'00001101'.
又比如：“+1”这个运算，你要先指示CPU做“+”，完成后再输入“1”数据给CPU。
8位的CPU优点是设计简单，处理速度比较快。
缺点就是：软件设计复杂，繁琐。不利于计算机的发展。

后来推出了16位的CPU，我们就可以一次处理两个字节（16位）的数据了，比如“加1”这个命令。“加”是一个指令，占用8个位，余下的8位我们可以存放数据“1”了。

32位的CPU就更加方便了，我们就可以一次处理一个a=a+b这样的命令了。

优点：简化了软件设计的复杂度
缺点：硬件设计更加复杂，计算速度下降。

一般来讲32位的CPU对于我们来讲是最理性的CPU，对于软件开发来讲足够了。

但是2的32次方 = 4294967296bit = 4G左右
很显然**32位CPU只有4G左右的内存寻址空间**，对于一些服务器来讲4G的内存的远远不够的了。我们需要更加大的内存寻址空间的话就需要对CPU进升级。64位CPU就这样诞生了。64位CPU的内存寻址空间是2的64次方（理论上）。

但是现在的AMD和Inter的64位CPU并不是真正意义上的64CPU，只是进行了部分64位的改进，比如64位的内存寻址等。
要是真的全部都是64位的了，那么现在市场上的软件将全部被淘汰不能使用了~呵呵，想像一下会是什么样子。

64位的操作系统针对64位CPU设计的，增加了一些64位的指令，但还是和32兼容的。对于我们普通用户来讲64位系统意义不大。



### 32位电脑与64位电脑有什么不同？

我们通常说的64位技术是相对于32位而言的，**这个位数指的是CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位**，64位指令集就是运行64位数据的指令，也就是说处理器一次可以运行64bit数据。



64位平台不管是在性能上，还是在功能上，都要领先于目前的32位平台，目前主流的32位处理器在性能执行模式方面存在一个严重的缺陷：当面临大量的数据流时，32位的寄存器和指令集不能及时进行相应的处理运算。32位处理器一次只能处理32位，也就是4个字节的数据；而64位处理器一次就能处理64位，即8个字节的数据。如果将总长128位的指令分别按16位、32位、64位为单位进行编辑的话：32位的处理器需要4个指令，而64位处理器则只要两个指令。显然，在工作频率相同的情况下，64位处理器的处理速度比32位的更快。除了运算能力之外，与32位处理器相比，64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，而64位处理器的一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。传统32位处理器的寻址空间最大为4GB，而64位的处理器在理论上则可以达到1800万个TB（1TB=1024GB）。



从32位到64位，表面上好象只是CPU字长增大了一倍，实际上它使寻址范围、最大内存容量、数据传输和处理速度、数值精度等指标也成倍增加，带来的结果就是CPU的处理能力得到大幅提升，尤其是对强烈依赖数值运算、存在巨量数据吞吐和需要超大并发处理的应用提升效果非常明显，如科学计算、人工智能、平面设计、视频处理、3D动画和游戏、数据库以及各种网络服务器等



## 使用C++区别不同位数的操作系统

在C++中，不同位数的操作系统会影响可用的数据类型和函数调用规则等方面。以下是一些常见的区别：

1. 数据类型：**在32位操作系统中，int、long和指针等数据类型通常占用4个字节（32位），而在64位操作系统中，这些数据类型通常占用8个字节（64位）**。因此，在编写跨平台代码时，需要特别注意数据类型的大小。
2. 内存管理：由于64位操作系统支持更大的内存地址空间，因此可以在更大的内存范围内分配和管理内存。此外，64位操作系统可以利用更多的寄存器来传递参数和执行函数调用，从而提高程序的性能。
3. 函数调用规则：在32位操作系统中，函数参数通常是通过堆栈来传递的，而在64位操作系统中，函数参数通常是通过寄存器来传递的。这意味着在64位操作系统上，函数调用的开销可能会更小，从而提高程序的性能。
4. 第三方库：在编写跨平台代码时，需要考虑使用的第三方库是否支持不同位数的操作系统。某些库可能只支持特定的操作系统或处理器架构，因此需要进行测试和兼容性调整。

```c++
#include <iostream>
using namespace std;

int main(){
    if(sizeof(void*) == 2){
        cout << "16-bit operating system" << endl;
    }else if(sizeof(void*) == 4){
        cout << "32-bit operating system" << endl;
    }else if(sizeof(void*) == 8){
        cout << "64-bit operator system" << endl;
    }else{
        cout << "Unknown operating system" << endl;
    }
    return 0;
}
```

