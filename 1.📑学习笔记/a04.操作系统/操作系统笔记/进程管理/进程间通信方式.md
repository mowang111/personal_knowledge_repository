---
title: 进程间通信方式
date: {{ date }}
top: false
cover: false
password:
toc: true
mathjax: true
summary:
tags: 
- 操作系统
- 进程
categories: []

---

本文引用自[小林malloc是如何分配内存的](https://xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93)

# 进程间通信方式

管道、消息队列、共享内存、信号量、信号、Socket

每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都是共享的，所以进程之间通信必须通过内核

![image-20230323103311434](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323103311434.png)

## 管道

### 匿名管道

```bash
ps auxf | grep mysql
```

其中`|`就是一个**管道**，它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，需要创建两个管道。

上述的管道是没有名字的，所以用`|`表示的管道称为**匿名管道**，用完后就销毁

### 命名管道

管道还有另一个类型是**命名管道**，也被叫做`FIFO`，因为数据是先进先出的传输方式。

使用命名管道前，需要通过`mkfifo`命令来创建，并且指定管道名字：

```bash
mkfifo myPipe
```

Linux一切皆文件，管道也是以文件的方式存在，使用ls命令可以查看，其文件类型为p

```bash
ls -l
prw-r--r--. 1 root    root         0 Jul 17 02:45 myPipe
```

接下来，往myPipe这个管道写入数据：

```bash
echo "hello" > myPipe  // 将数据写进管道
                         // 停住了 ...
```

你操作了后，你会发现命令执行后就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。

于是，我们执行另外一个命令来读取这个管道里的数据：

```bash
cat < myPipe  // 读取管道里的数据
hello
```

**管道这种通信方式效率很低，不适合进程间频繁地交换数据**

### 管道创建的原理

匿名管道的创建需要通过下面这个系统调用：

```c
int pipe(int fd[2])
```

这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符`fd[0]`,另一个是管道的写入端描述符`fd[1]`。注意，这个匿名管道是特殊的文件，只存在于内存，不存在于文件系统。

**所谓的管道，就是内核里面的一串缓存。**从管道的一端写入的数据，实际上是存在内核中的，另一端读取，也是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。

#### 管道沟通父子进程

此时，两个文件描述符都是在一个进程中，如果使其跨过两个进程？

可以使用`fork`创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个【`fd[0]`和`fd[1]`】，两个进程就可以通过各自的fd写入和读取同一个管道文件实现跨进程通信了

管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：

+ 父进程关闭读取的 `fd[0]`，只保留写入的 `fd[1]`；
+ 子进程关闭写入的 `fd[1]`，只保留读取的 `fd[0]`；

![image-20230323112730761](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323112730761.png)

#### shell中的管道通信

在 shell 里面执行 `A | B`命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell。

![image-20230323112924085](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323112924085.png)

> 对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过fork来复制父进程fd文件描述符，来达到通信的目的
>
> 对于命名管道，它可以在不相关的进程间也能相互通信。因为命名管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。
>
> 不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据的时候也是从内核中获取，同时通信数据都遵循先进先出的原则，不支持lseek之类的文件定位操作



## 消息队列

管道的通信方式是非常低的，因此管道不适合进程间频繁地交换数据。

对于这个问题，消息队列的通信模式就可以解决。比如，A进程要给B进程发送消息，A进程把数据放在对应的消息队列中就可以正常返回，B进程需要的时候再去读取数据即可。

**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。

**消息队列的不足有两点，一是通信不及时，二是传输数据有大小限制。**

**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在Linux内核中，会有两个宏定义`MSGMAX`和`MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。

**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一个进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。

## 共享内存

消息队列的读取和写入的过程，都会有发生用户态与内核态之间消息拷贝过程。那**共享内存**的方式就很好的解决了这个问题。

现代操作系统中，对于内存管理，采用虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程A和进程B的虚拟地址时一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。**这样这个进程写入的东西，另一个进程马上就能看到了，不需要互相拷贝，大大提高了进程间的通信速度。

![image-20230323115932027](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323115932027.png)

## 信号量

用共享内存通信方式，带来了新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能产生冲突。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。

为例防止多进程竞争共享资源，而造成的数据错乱，所以就需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。**信号量**就实现了这一保护机制。

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥和同步。**

信号量表示资源的数量，控制信号量的方式有两种原子操作：

+ 一个是**P操作**，这个操作会把信号量减去1，相减后如果信号量<0，则表明资源已被占用，进程需要阻塞等待；相减后如果信号量>=0，则表明还有资源可使用，进程可正常继续执行。
+ 另一个是**V操作**，这个操作会把信号量加上1，相加后如果信号量<=0，则表明当前有阻塞中的进程，于是会将改进程唤醒运行；相加后如果信号量>0，则表明当前没有阻塞中的进程。

P操作用在进入共享资源之前，V操作时用在离开共享资源之后，这两个操作必须成对出现。

## 信号

上面说的进程间的通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用信号的方式来通知进程。**

在Linux操作系统中，为了响应各种事件，提供了几十种信号，分别代表不同的意义，可以使用`kill -l`命令，查看所有信号：

```bash
$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

运行在shell终端的进程，可以通过键盘组合键给进程发送信号：

+ Ctrl+C产生`SIGINT`信号，表示终止该进程
+ Ctrl+Z产生`SIGTSTP`信号，表示停止该进程，但还未结束

如果进程在后台运行，可以通过`kill`命令的方式给进程发送信号，但需要知道进程的PID号

+ `kill -9 1050`表示给PID为1050的进程发送`SIGKILL`信号，用来立即结束该进程

所以，信号事件的来源主要有硬件来源（如键盘）和软件来源（如kill命令）。

**信号是进程间通信机制种唯一的异步通信机制，因为可以在任何时候发送信号给某一进程。**一旦有信号产生，有以下几种用户进程对信号的处理方式：

1. **执行默认操作**。Linux对每种信号都规定了默认操作，例如，上面的`SIGTERM`信号，就是终止进程。
2. **捕捉信号**。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。
3. 忽略信号。当我们不希望处理某些信号时，就可以忽略该信号，不做任何处理。有两个信号时应用进程无法捕捉和忽略的，即`SIGKILL`和`SEGSTOP`,它们用于在任何时候中断或结束某一进程。

## Socket

前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要**想跨网络与不同主机上的进程之间通信，就需要Socket通信了**。

实际上，Socket通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

```c
int socket(int domain, int type, int protocal)
```

三个参数分别代表：

+ domain参数用来指定协议族，比如`AF_INET`用于`IPV4`、`AF_INET6`用于`IPV6`、`AF_LOCAL/AF_UNIX`用于本机。
+ type参数用来指定通信特性，比如`SOCK_STREAM`表示的是字节流，对应`TCP`、`SOCK_DGRAM`表示的是数据报，对应`UDP`、`SOCK_RAW`表示的是原始套接字
+ protocal参数原本是用来指定通信协议的，但是先基本废弃。因为协议已经通过前面两个参数指定完成，protocal 目前一般写成 0 即可；

根据创建socket类型不同，通信方式也就不同：

- 实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；
- 实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；
- 实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；

### 三种通信的编程方式

#### 针对TCP协议通信的socket编程模型

![image-20230323122809345](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323122809345.png)

+ 服务端和客户端初始化`socket`，得到文件描述符；
+ 服务端调用`bind`，绑定IP地址和端口；
+ 服务端调用`listen`，进行监听；
+ 服务端调用`accept`，等待客户端连接；
+ 客户端调用`connect`，向服务器端的地址和端口发起连接请求；
+ 服务端`accept`返回用于传输的`socket`文件描述符；
+ 客户端调用`write`写入数据；服务端调用`read`读取数据；
+ 客户端断开连接时，会调用`close`，那么服务端`read`读取数据时，就会读取到`EOP`，待处理完数据后，服务端调用`close`，表示连接关闭；

这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。

所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。

成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

#### 针对UDP协议通信的socket编程模型

![image-20230323123257434](https://raw.githubusercontent.com/mowang111/image-hosting/master/typora_images/image-20230323123257434.png)

UDP是没有连接的，所以不需要三次握手，也就不需要像TCP调用listen和connect，但是UDP的交互仍然需要IP地址和端口号，因此也需要bind

对于UDP来说，不需要维护连接，那么也就没有所谓的发送方和接收方，甚至不存在客户端和服务端的概念，只要有一个socket多台机器就可以任意通信，因此每一个UDP的socket都需要bind。

另外，每次通信通信时，调用sendto和recvfrom，都需要传入目标主机的IP地址和端口。

#### 针对本地进程间通信的socket编程模型

本地socket被用在同一台主机上进程间通信的场景：

+ 本地socket的编程接口和IPv4、IPv6套接字编程接口时一致的，可以支持【字节流】和【数据报】两种协议
+ 本地socket的实现效率大大高于IPv4、IPv6的字节流、数据报socket实现。

对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。

对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。

**本地字节流socket和本地数据报socket在bind的时候，不像TCP和UDP要绑定IP地址和端口，而是绑定一个本地文件，这就是它们之间最大的区别。**

## 总结

由于每个进程的用户空间是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，因为每个进程都是共享一个内核空间。

Linux内核提供了不少进程间的通信方式，其中最简单的方式就是管道，分为【匿名管道】和【命名管道】。

+ **匿名管道**，比如shell命令种的`|`竖线，其是特殊文件只存在于内存，没有存在于文件系统中，**通信的数据是无格式流并且大小受限**，**通信的方式是单向的**，如果要双向通信，需要创建两个管道，**匿名管道只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失**。
+ **命名管道**突破了匿名管道只能在父子进程间通信的限制，因为使用命名管道前，需要在文件系统创建一个类型为P的设备文件，可以通过该设备文件通信。另外，不管是匿名管道还是命名管道，进行写入的数据都是**先缓存在内核中**，另一个进程读取数据时也是从内核中获取，同时通信数据都是遵循**先进先出**的原则，不支持lseek之类的文件定位操作。

**消息队列克服了管道通信的数据是无格式的字节流的问题**，消息队列实际上是保存在内核中的**消息链表**，消息队列的消息体是可以用户自定义的数据类型，发送数据的时，会被分成一个一个独立的消息体，当然接收数据时，也要于发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟**每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程**。

**共享内存可以解决消息队列通信中用户态与内核态之间的数据拷贝过程带来的开销**，它直接分配一个共享空间，每个进程都可以直接访问，**不需要陷入内核态或者系统调用**，大大提高了通信速度，是**最高效的进程间通信方式**，**其带来的新问题就是，多进程竞争同个共享资源会造成数据错乱**。

于是，需要**信号量来保护共享资源**，以确保任何时刻只能有一个进程访问共享资源，这种方式就是**互斥访问**。**信号量不仅可以实现访问的互斥性，还可以实现进程间的同步**。信号量其实是一个计数器，表示资源个数，其值可以通过两个原子操作来控制，分别是P操作和V操作。

上面说的进程间的通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用信号的方式来通知进程。信号是进程通信机制中唯一的异步通信机制**，信号可以在应用进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，**信号事件的来源主要有硬件来源和软件来源**，一旦有信号发生，进程有三种方式相应信号：**执行默认操作、捕捉信号、忽略信号**。有两个信号是应用进程无法捕捉和忽略的，即`SIGKILL`和`SIGSTOP`,这是为了方便我们能在任何时候结束或停止某个进程。

前面说的通信机制，都是工作在同一台主机，**如果要与不同主机的进程间通信，那么就需要Socket通信**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的方式呢？

同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步。

+ 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
+ 同步的方式，可保证线程A应在线程B之前执行。
