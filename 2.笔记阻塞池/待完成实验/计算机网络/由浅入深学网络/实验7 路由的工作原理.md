## 一、实验介绍

通过前几章节的实验我们较为深入的了解交换机中的相关技术，并使用相关的技术，这些都是应用于局域网中的，本节实验将了解异构网络之间，不同网段之间如何通信。

### 1.1 实验涉及的知识点

- 路由器的简介
- 路由的转发过程
- 路由的转发机制
- 路由表
- 基本命令

## 二、路由器的简介

我们都知道交换机是工作于数据链路层中，当收到数据帧便查看源 MAC 地址与目的 MAC 地址，知道地址便转发，不知道地址便广播找地址，这在小范围的局域网络中已经足以使用，小型网络中通过广播来找地址并不会有太大的时延。

但是当我们的网络扩大了呢？当我们的网络与其他的网络相互连接了，当我们接入 Internet 了，这种方式将不再靠谱，效率十分的低下，并且广播只能在广播域中传播，这种方式将不再可行。所以就有了网络层的出现，工作于网络层，用于连接异构网络、连接不同网段的设备是路由器（Router）。

所谓的路由便是路由器从一个接口上收到数据包，根据数据包的目的地址进行分组的转发，寻找路径转发到另外的接口的过程。

就像是我们从公司回家有很多条路径可以选择，做不同的公交车走不同的路线，我们选择出了一条最优最快的路径，坐上公交车，公交车一站一站的将我送到目的地这个过程就是我们的路由。

为我们数据包分组、寻找最佳的回家路径的工具便是我们的路由器。路由器与交换机不同，交换机是由集成电路所组成的交换芯片来进行数据包的转发，而路由器不同，路由器就像是一种特殊的计算机，他拥有计算机该有的元素：CPU、操作系统、内存、存储，其中主要依靠的是 CPU。

在 Cisco 设备中的路由器运行的操作系统叫 IOS（Internetwork operating system），在第一章节实验中我们便介绍了。曾经在 Cisco 中有这样的一部分员工认为 FreeBSD 这个开源的 Linux 操作系统更适合做路由器的操作系统，但是上司并不认可，所以这部分员工出来开创了 Juniper。这个品牌已经占据了全球不小的市场了。该品牌的路由器上运行的便是 FreeBSD 这个操作系统。

由此看出路由器其实就是一个另类小型的计算机。

在路由器中有这样的一些组件以及其功能：

- CPU：用于执行操作系统的命令
- 随机访问存储器 RAM（RAM 中的内容在断电的时候会丢失），有这样一些作用
  - 运行操作系统。与计算机相同，运行的进程、操作系统都与在内存中运行
  - 运行配置文件。在路由器上做的所有配置都会保存成文件，在开机时读取
  - 存放 IP 路由表。为了更快的计算出路由路径，所以路由表存放在内存中
  - ARP 缓存表。为了更快的寻找到 IP 所对应的 MAC 地址，所以 ARP 缓存表存放在内存中
  - 数据包缓存区。作为数据包的临时存放区域
- 只读存储器 ROM（其中的内容并不会丢失，同时还不能修改，是在出厂的时候烧录上去的）
  - Bootstrap 指令。引导路由器整个开机过程的
  - 硬件的基本自检程序 POST（Power on self test）
  - 迷你版 IOS，简化版的操作系统，用于在操作系统丢失，无法正常进入操作系统时紧急恢复
- 非易失性 RAM（NVRAM）。即在断电之后也不会丢失数据，用于存储启动配置，包括 IP 地址、路由协议，主机名等等。基本很少使用了。
- Flash 闪存。存放我们的操作系统镜像如 IOS，相当于我们的硬盘。NVRAM 的淘汰，便是将数据存放在 Flash。

在路由中的启动顺序是：

- 检测路由器的硬件：
  - Power On Self Test（POST）就是加电自检，用于在开机之前检查所有的组件是可以运行的
  - 执行 bootstrap 程序，来引导剩下的开机软件
- 定位 IOS 系统软件的位置
- 将 IOS 拷贝到 RAM 中加载执行
- 定位并加载已有的配置文件
- 进入到配置模式中

![start process](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477146271017.png) （此图来自于[新客网](http://www.xker.com/page/e2012/0528/116335.html)）

登陆到路由器上有这样几种方式：

- 连接 Console 口：通过 Console 线连接到路由的 Console 上来进行初始化配置
- Telnet 或者 SSH 远程登陆：通过 Telnet 或者 SSH 远程连接终端，远程登陆上路由器的终端，通常在运行过程中，设备不同的地方，远程登陆修改配置
- 辅助端口：AUX 的辅助端口，在很少的特殊设备中还在使用

这就是路由器上的组件以及这些组件的作用。我们可以在我们的模拟工具中运行相关的命令来查看这些信息。首先我们在终端中打开 GNS3，并在我们的汇总设备中找到 `router` 设备，同时开启它，并登陆它：

![get-router.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477147319059.png)

在登陆的时候我们会看到这样的一些信息，这些信息就是 POST 在检查我们的硬件设置的过程，并通过 bootstrap 启动引导去执行开机所做的一些事情：

![show-bootstrap-info1.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283312423.png)

![show-bootstrap-info2.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283347501.png)

在登陆特权模式之后我们可以通过这样的一个命令来查看我们 IOS 相关的一些信息，以及一些运行信息：

```
show version
```

![show-version.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283439887.png)

![show-version2.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283763952.png)

还可以通过这个命令来查看系统运行程序的一些相关信息：

```
show process CPU
```

![show-process-CPU.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283500733.png)

在这个命令中我们可以看到 CPU 的利用率使用率的一些信息，以及系统中这在运行中进程的信息如 PID、RUNTIME 等等的信息。就像我们在 Linux 中运行 `top` 命令一般。

```
show protocols
```

![show-protocols.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283595470.png)

在这个命令中我们可以看到系统中现在所运行的协议，以及相关端口所处的状态。

这些命令都是查看 CPU、运行程序的一些系统的状态，我们可以通过这个命令来查看当前我们设备的配置情况，显示的便是系统中内存所加载的运行配置文件，所以所有运行中的配置都会展现出来：

![show-running-config.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283745452.png)

我们还可通过这样的一个命令来查看我们的内存信息，以及一些使用的情况：

```
show memory
```

![show-memory.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477283814788.png)

与之类似的命令还有 `show stacks`、`show buffers` 这是查看系统栈与缓存区中的一些信息，自己尝试一下把。

刚刚我们提到了如何查看运行中的配置，但是这一切在重启之后都会消失，因为这些运行中的配置都是存储在 RAM 中，在断电之后就会丢失，而在启动路由器的时候，会寻找 NVRAM 或者是 Flash 中保存的配置文件，然后拷贝至 RAM 中加载、运行，所以在重新启动之后系统的配置是启动配置信息中的内容。

我们可以通过这样的命令来查看其中的内容：

```
show startup-config
```

既然有这样的问题说明我们以前所做的所有配置在断电之后都会消失，所以我们以后在更新或者做了配置之后确认无误的情况下都应该把 running-config 中的内容复制保存到 start-config 中去。我们可以通过这两个命令来帮助我们完成这件事情：

```
#将运行配置覆盖掉启动配置
copy running-config start-config

#或者使用这个命令，将运行配置复制到 NVRAM 中去，这是一个意思
write
```

还可以通过 `show interface` 查看所有端口的详细信息。

这就是一些针对于路由器组件结构的一些相关常用的命令，总的来说可以用这张图来概括

![show all command](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477284085422.png) （此图来自于[highteck.net](http://www.highteck.net/images/298-Testing-IOS-show-commands.jpg)）

由此我们便对路由的功能与结构有了一定的了解。

## 三、路由的转发过程

路由器的主要功能是将数据包转发到目的地，在这个过程中路由器将从某个接口中接收到的数据包通过另一个接口转发出去。我们通过这样的例子来具体的了解每个步骤：

![forward-example.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477284563927.png)

- PC1 希望发送数据包给 PC2，而 PC1 首先确定目的 IP 地址是否在同一个网络中（通过 IP 地址与子网掩码的和运算，得出网络号然后对比使用同样方法得出的 PC2 的网络号）：
  - 若是网络号相同则通过 ARP 转发数据包；
  - 若是网络号不同则通过将数据包转发给默认网关（将在后续课程中详解）。
- Router1 接收到 PC1 的以太帧，将该帧复制到 buffer（缓冲区）中，分用得到以太帧的类型（确定其中包含 IP 数据包）、目的 MAC 地址是接收端口的 MAC 地址，确认该数据包是该自己接收的，便继续分用 IP 数据包头得到目的 IP 地址，发现 IP 地址与自己的所有端口都不匹配，便知晓此数据包并不是发给自己的，同时与自己不在同一个网段，便查询自己的路由表：
  - 若是路由表中并没有该网段的信息便丢弃；
  - 若是路由表中有该网段的信息，变查看路由表中所记录该网段应该从哪个端口转发出去。
- Router1 在路由表中查到所应该转发的端口便修改原来的数据帧中源 MAC 地址与目的 MAC 地址，然后就转发给下一跳的 Router2
  - 若是 Router 直接连接的端口是以太网口（例如 ethernet，fastethernet）将继续使用以太帧的封装方式
  - 若是 Router 直接连接的端口是串口（例如 Serial 口）将使用 PPP 的点到点的协议封装方式封装数据帧
- Router2 在收到数据包之后以同样的方式分用确实数据包的类型与 MAC 地址，最后得到目的 IP 地址，发现改网段是自己直连的网段，便查看 ARP 缓存表：
  - 若是 ARP 缓存表中有该 IP 地址与 MAC 地址的记录便直接转发给 PC2；
  - 若是 ARP 缓存表中无该 IP 地址与 MAC 地址的记录便发送 ARP 请求来获取 PC2 的 MAC 地址；
- 这样便是路由器完成一次数据包转发的任务。

这便是路由器在接收到数据包到转发数据包的整个过程。其中转发到的下一个路由器成为下一跳（类似于公交车、地铁的下一站），并且因为当前这一跳与下一跳的链路可能与原来的不同，所以新封装的数据帧的协议与格式可能略有不同（例如交换机发给路由器是是用的以太网的封装协议，而路由器直接使用的是串口连接，此时数据帧的封装协议便会改成 PPP）。

## 四、路由的转发机制

在上文中我们了解到路由的最主要作用就是对数据包分组并且寻找转发的路线，转发数据包。就像交换机在对数据帧转发时会查询 MAC 地址以求更快的转发，在路由器中有一张路由表，他存放在内存中，如地图一般，收到数据包就会在路由表中查看，有这个网段，认识路，便转发数据包，若是地图中便没有该目的地网段，便会丢弃该数据包，因为它不认识路，无法继续转发下去。

这就是路由表的功能，路由表负责寻址，找到最佳的路由路。找到了最佳路由之后便需要将数据包转发出去，在路由器中数据的转发机制有三种：

- 进程交换
- 快速交换
- 思科快速转发（CEF）

其中进程交换是一种非常早期之前的一种数据包转发机制。当数据包到达某个端口的时候会发送给控制转发的程序，CPU 将接受的数据包拆解所获得的 IP 目的地址与路由表中的条目进行对比，一旦匹配便使用其相应的端口转发数据包。虽然这个过程看起来似乎并没有什么问题，但其实问题在于接收到的所有数据包都必须通过 CPU 来进行计算与搜索匹配，即使收到的数据包流的目的地址都相同。

这样的转发机制效率十分低下，每一个数据包的到来都会独享 CPU 资源，并且即使此次计算的内容与上一次的计算内容完全一致。这样让高效率的 CPU 做这样重复动作非常不明智。就像是我在做了 `1+1` 这个算数题之后知道了答案，然后再次做到这道题，我还要重新计算一遍。

在了解到进程转发机制所带来的问题之后便出现了一种新的解决方案，既然认为 CPU 在计算了 `1+1` 之后便知道了答案，不需要在计算一遍，便找一个专门的地方来存放结果，这样在再次遇到同样的 `1+1` 题目之后我们便不需要再次计算他的值，可以直接查看答案。这种转发机制便是快速交换。

当路由器第一收到数据包通过 CPU 计算出最佳的路径之后，便将这一过程存放在快速交换缓存表中，这样在下一次遇到相同的目的 IP 地址时便不用重新计算路由的路径，可以之间查询快速交换缓存中的数据，便知道结果，然后根据结果来转发数据包。这样便有效的减少 CPU 做同样事情的事情。

但是这样同样存在问题，CPU 的计算是被动的，只有在接受到数据包的时候才会去计算，这样第一个数据包的转发速度是很慢的。由此 Cisco 开发出了一种新的数据包的转发机制：思科快速转发（CEF，Cisco Express Forwarding）。

CEF 将构建转发信息库 (FIB) 和邻接表。在网络刚刚创建或者拓扑发生更改的时候，当网络融合后 FIB 与 邻接表会将转发数据包的所有因素都考虑到然后计算出最佳的路径集合，如此在数据包到来的时候可以直接查询到结果然后进行转发这样就不用再数据包到来的时候计算，这样便进一步的节省了转发所需的时间。

这就是三种路由转发数据包的机制，他们的过程就像这样的一个场景：

- 从公司到家的路并不认识，便开导航指引我前进。而我从来记不住路，每天回家都必须开启导航。（进程交换）
- 从公司到家的路并不认识，第一次回去便开启导航指引我前进，一次我们记住路了，以后回去便不用开导航了，可以通过记忆开回家。（快速交换）
- 在第一次去公司之前的一天我便通过网上的地图找好从公司回家的路线，这样在第二天回家的时候我连导航都不用开便能够直接开回家。（CEF）

这便是路由器的数据包转发机制，在 Cisco 设备中 CEF 的数据包转发机制是默认开启的，但是若是不想使用这个转发机制时可以通过这样的一个命令来关闭该功能：

```
no ip cef
```

## 五、路由表

路由表的搜索将决定数据包下一步该如何转发，搜索到的结果有这样三种：

- 直连网络：如上述例子中 Router2 与 PC2 的情况，目的 IP 地址与路由器的某个端口属于同一网络中，这样便是直连网络，这样的网络会通过 ARP 直接将数据包转发给目的主机。
- 远程网络：如上述例子中 Router1 与 Router2 相连的情况，目的 IP 地址与路由中所有的端口都不在同一网络中，但是路由表中有该网络的信息，需要将数据包转发给其他的路由器，通过他们转发给目的主机，这样的网络便是远程网络。这样的网络需要通过将数据包转发给下一跳。
- 无法路由：这样的数据包中目的 IP 地址所在的网络在路由表中找不到，既不是直连也不是远程，若是配置有默认网关将发送给默认网关，若是没有配置默认网关将直接丢弃数据包。

路由表是保存在 RAM 中的数据文件，其中存储了与直连网络以及远程网络相关的信息。直连网络便是自己活动端口所处于的网络，远程网络便是活在在其他设备上的网络，这便是路由器中的路由表：

![show-ip-route.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477285814608.png)

通过这个命令可查看：

```
show ip route
```

图中我们可以看到直连路由表的条目与静态路由表的条目。所有的路由表的内容相差不大，其中静态路由与直连路由的较为简短，远程的动态路由信息较为繁多这里以动态路由信息为例：

![ospf.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477290108389.png)

在路由表中每一项有这样一些信息：

- 路由来源：确定该路由表项的获取方式：是直连；还是通过静态或动态路由协议所获得
- 目的网络：确定远程网络的网络号，也就是网络地址。
- 管理距离（AD）：AD 代表路由的“可信度”；AD 越低，路由来源的可信度越高，表示首选路由来源。获取方式的不同 AD 的值也就不同。当同一个目的地址有不同的路径时，这将是一个参考值，指明了发现路由方式的优先权。
- 度量： 路由协议会给确定到达远程网络每一条路径计算出一个数，这个数就是度量值。 较低的值表示首选路由， 因为度量值（Metric）指明了路径的优先权
- 下一跳：用于确定转发数据包的下一路由器的 IP 地址。
- 路由时间戳：用于确定从获取该路由信息之后经历了多长的时间。
- 传出接口：用于确定将数据包转发至最终目的地的发出接口。

> **管理距离**：英文缩写 AD，全称 Administrative Distance。大多数的路由协议有与其他协议所不兼容的算法与衡量结构、参考标准。在具有多个路由协议的网络中，路由信息的交换和选择最好的路径的能力很重要。AD 便是一个综合的衡量标准，由此选择出最佳的路径。

## 六、基本命令

在路由器中有这样一些常用的挤出命令：

1.为一个端口配置 IP 地址，这是我们在之前的试验中最常用的命令：

```
#进入全局模式
conf t

#配置 e0/0 端口
interface e0/0

#配置 IP 地址
ip address ip地址 子网掩码
```

2.为路由器配置环回接口的 IP 地址：

```
#接口+环回表示+接口id
int loopback 0

#配置 IP 地址
ip address ip地址 子网掩码
```

> **环回接口**习惯上被称为 loopback 接口，是路由器上的一个逻辑、虚拟接口。看不见摸不着的存在，被十分广泛的应用，可以用来做路由协议中的 Router-ID、网络测试等等功能。

3.验证端口是否配置成功，在特权模式中使用这样的命令：

```
#查看所有端口 IP 概要信息
show ip int brief

#查看某个端口上运行的配置信息
show running-config interface 端口ID
```

4.过滤 show 命令的显示信息。默认情况下，生成多页输出的命令在显示出 24 行后会暂停。 在暂停输出的结尾处，将会显示`--more--`。 按 Enter 回车键显示下一行，按空格键显示下一组输出。当我们信息过多需要过滤时，我们会在 show 的命令后面接上管道符以及过滤参数，过滤参数分为四类：

- section：显示从过滤表达式开始的整组部分信息
- include：显示所有符合过滤表达式的信息
- exclude：排除所有符合表达式的信息
- begin：显示从符合表达式开始之后的所有信息

![show-filter.png](https://doc.shiyanlou.com/document-uid113508labid2213timestamp1477295253751.png)

5.查看历史命令，以前的实验中我们教大家使用箭头上或者下来查看之前与之后的命令，我们还可以通过 `ctrl+P` 与 `ctrl+N` 来上下翻看历史记录。默认情况下，系统会在其历史记录缓冲区中记录最新输入的 10 条命令。使用 `show history` 命令显示缓冲区的内容。

## 七、实验总结

通过本实验我们了解到路由器是什么，以及路由器中的组件及其作用。在路由器运行时最重要的便是路由表中的寻址，以及数据包的转发机制。粗略的认识了路由器在数据包转发的过程，以及再次了解 IOS 中的一些调试命令与常用的配置命令。

## 八、参考资料

[1]环回接口：http://baike.baidu.com/view/2177818.htm [2]AD 管理距离：http://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/15986-admin-distance.html