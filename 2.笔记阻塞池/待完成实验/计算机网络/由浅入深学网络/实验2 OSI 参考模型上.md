## 一、实验介绍

OSI 参考模型在市面上，商业领域上没有获得多大的成就，但是在理论成果上还是有很多学习的价值，本节实验我们将进步了解该模型前三层的主要功能，并通过一个小实验来了解某个协议的通信过程。在地址换算的部分涉及到进制转换，学习本章节之前请学会进制转换。

### 1.1 实验涉及的知识点

- OSI 数据通信过程
- 物理层
- 数据链路层
- 网络层

## 二、 OSI 数据通信过程

上一节实验中我们了解到了 OSI 将所有的协议按照功能性的划分，分成了七层，从而出现了 OSI 参考模型的这个七层框架，而用户数据在从源地址的应用程序发出，到目的地址会经历一个怎样的过程呢？

![Networking_7layer.png](https://doc.shiyanlou.com/document-uid113508labid1timestamp1474438806339.png) （此图来自于[ntu.edu](https://www.ntu.edu.sg/home/ehchua/programming/java/images/Networking_7layer.png)）

如图中所示，假设此时有两个节点的两个应用相互通信分别为 Application1 与 Application2。显然两台计算机之间一般情况不会是直连的，中间会有路由器等等的其他网络设备，图中假设有两台路由器。

用户的原始数据不可能直接的传输到目的应用程序中，因为这样网络会很混乱，没有办法协调，并且我们的最底层只能传输 1、0 这样的比特流，所以用户的原始数据必然会经过一定的加工处理。数据从应用程序中出来，进入 OSI 参考模型的协议簇，数据在协议层次当中自顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。

这样在数据的头部或者尾部添加信息的举动称之为封装。

![encapsulation.jpg](https://doc.shiyanlou.com/document-uid113508labid1timestamp1474440381767.png) （此图来源与[routemybrain](http://cdn.routemybrain.com/wp-content/uploads/2010/04/encapsulation.jpg)）

而每一层被添加信息后的数据都有一个不同的名字：

- 物理层（一层）添加 PDU 后称为：数据位（Bit）
- 数据链路层（二层）添加 PDU 后称为：数据帧（Frame）
- 网络层（三层）添加 PDU 后称为：数据包（Packet）
- 传输层（四层）添加 PDU 后称为：数据段（Segment）
- 第五层以上为数据（data）

被层层武装起来的数据最后在物理层以只有 1、0 的 bit 流传输到只有三层结构的路由器中（因为路由并不是最终的接收端，只有转发的作用，只需要用到前三层的功能，所以只有三层。）。

首先路由器的物理层接收来自远端的 bit 流，将其转化为数据链路层所能看懂的数据帧，而数据链路层又将其转化为网络层所能看懂的数据包，网络层看到数据包中的源地址以及目的地址之后，通过其手中的地图（也就是后续会提到的路由表）为其选择下一站。然后由经过层层的武装，将其变成比特流传输给下一个路由器，后续的路由器做相同的操作，直到 Application2 所在的节点。

Application2 所在的计算机在接收到比特流之后，又结果层层的转化（从比特流-->数据帧-->数据包-->数据段-->数据），也就是将之前所加的 PDU 一层一层的去掉，还原出 Application1 所发出原始的数据。数据就是这样跋山涉水的传输的。

当主机收到一个数据帧时，数据就从协议底层向上传输，每通过一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反，这个解封的过程称之为分用。

这便是数据在 OSI 参考模型中的传输的过程与变化。简单来说就是从参考模型的顶部到底部一层层的封装，然后再在目的端一层层的分用，最后获取到原始的数据。

![osi_header_trailer.jpg](https://doc.shiyanlou.com/document-uid113508labid1timestamp1474443033814.png) （此图来自于[zaielacademic](http://zaielacademic.net/networking/images/osi_header_trailer.jpg)）

我们需要建立的是这样的概念：OSI、TCP/IP 模型都只是一个分类的标准，而让标准产生作用的是规则，而规则便是协议实现的。所以 TCP/IP 模型整体来看就是一个协议的集合，所以又称之为 TCP/IP 协议簇，TCP/IP 协议栈。

大概了解了数据是如何在节点间变化与穿梭，但是对每一层的作用还是没有一个明确的感知，所以我们将进一步的了解每一层所涉及到的内容。

## 三、物理层

首先我们来了解下物理层到底是干嘛？物理层主要功能：为数据端设备提供传送数据通路、传输数据。

- 为数据端设备提供传送数据的通路：数据通路可以是一个物理媒介（物理媒介也就是传送的介质，如架空明线、双绞线、对称电缆等等），也可以是多个物理媒介连接而成。一次完整的数据传输，包括激活物理连接，传送数据，终止物理连接。所谓激活，就是不管有多少物理媒介参与，都要在通信的两个数据终端设备间连接起来，形成一条通路。
- 传输数据：物理层要形成适合的数据传输，需要实体提供传送服务。一是要保证数据能正确通过，二是要提供足够的带宽（带宽是指每秒钟内能通过的比特数），以减少信道上的拥塞。传输数据的方式能满足点到点，一点到多点，串行或并行，半双工或全双工，同步或异步传输的需要。
- 完成物理层的一些管理工作。

物理层在实现功能时要解决的主要问题：

- 物理层要尽可能地屏蔽掉物理设备和传输媒体的差异产生的影响，即使通信手段的不同，但要使得数据链路层感觉不到这些差异，从而顺利的完成本层的协议和服务。由于物理连接的方式很多，传输媒体的种类也很多（如架空明线、双绞线、对称电缆、同轴电缆、光缆，以及各种波段的无线信道等），因此，具体的物理协议相当复杂。
- 物理层应该解决物理连接的建立、维持和释放问题。
- 在两个相邻系统之间唯一的标识数据电路。

用于物理层的协议也称为物理层规程（procedure）。

由于在 OSI 之前，许多物理规程或协议已经被制定出来了，而且在数据通信领域中，这些物理规程已被许多商品化的设备所采用，加之，物理层协议涉及的范围广泛，所以至今没有按 OSI 的抽象模型制定一套新的物理层协议，而是沿用已存在的物理规程，将物理层确定为描述与传输媒体接口的四大特性（类别），机械，电气，功能和规程特性。

信号的传输离不开传输介质，而传输介质两端必然有接口用于发送和接收的信号。因此，既然物理层主要关心如何传输信号，那么物理层的主要任务就是规定各种传输介质的接口与传输信号相关的一些特性。

- **机械特性** 也叫物理特性，指明通信实体间硬件连接接口的机械特点，如接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。这很像平时常见的各种规格的电源插头，其尺寸都有严格的规定。 DTE（Data Terminal Equipment，数据终端设备，用于发送和接收数据的设备，例如用户的计算机）的连接器常用插针形式，其几何尺寸与 DCE（Data Circuit-terminating Equipment，数据电路终接设备，用来连接 DTE 与数据通信网络的设备，例如 Modem 调制解调器）连接器相配合，插针芯数和排列方式与 DCE 连接器成镜像对称。
- **电气特性** 规定了在物理连接上，导线的电气连接及有关电路的特性，一般包括：接收器和发送器电路特性的说明、信号的识别、最大传输速率的说明、与互连电缆相关的规则、发送器的输出阻抗、接收器的输入阻抗等电气参数等。
- **功能特性** 指明物理接口各条信号线的用途，包括：接口线功能的规定方法，接口信号线的功能分类--数据信号线、控制信号线、定时信号线和接地线4类。
- **规程特性** 指明利用接口传输比特流的全过程及各项用于传输的事件发生的合法顺序，包括事件的执行顺序和数据传输方式，即在物理连接建立、维持和交换信息时，DTE/DCE 双方在各自电路上的动作序列。

以上 4 个特性实现了物理层在传输数据时，对于信号、接口和传输介质的规定。

基于这样的一些规定，使得数据链路层不用过多的考虑与底层相关的信息。

在具体表现的方面，联系上文我们说数据在层与层之间传递的时候都会在数据包前面加上相应的头部信息，同样在物理层的时候，物理层会在数据链路层传递下来的数据包前面加上 Preamble 与 SFD 这样的头部信息，使得数据包变成这样的一种形态：

数据帧（比特流是物理层中传输数据的名字，但是一般在以太网中仍称之为数据帧）= Preamble + SFD + 帧（由数据链路层所传递而来）+ EOF（很多情况下并没有该结束符）

- Preamble 翻译为序言，将占用 7 bytes（or octets，相同的单位），也就 56 bit，它所起到作用是同步硬件同步信号，为了让接收端做好接收的准备时钟与源主机发送器时钟同步（allowing devices on the network to easily synchronize their receiver clocks）。
- SFD（start frame delimiter：帧开始定界符），将占用 1 byte，也就是 8 bit。它的作用是标志着 Preamble 同步信号的结束，以及帧数据部分的开始。
- EOF（end of frame:帧结束），同样占据着 1 byte，它将标志着帧的部分的结束。

转变成这样的结构之后，物理层再将这数据帧转变为只有 0、1 的比特流在物理线路上传输，若还是觉得抽象，大家可以看 wireshark 中 Packet 面板的最后一层（默认是显示的 十六进制，可以右键选择 Bit view），如图所示：

![bitstream.png](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1476268703400.png)

这就是数据在链路上传送的数据流，只有 0、1 组成的。

在物理层中常用的协议有 RS-232、RS-449、X.21、V.35、ISDN、以及FDDI、IEEE802.3、IEEE802.4、和IEEE802.5。

这只是一个粗略的认识，大家可以通过[这篇文章](http://wiki.dzsc.com/info/4187.html)与[这本书](https://books.google.com.hk/books?id=nzoJ2QXnM9IC&pg=PA81&lpg=PA81&dq=物理层相关内容&source=bl&ots=he9Y1egBx_&sig=zRkN7CUSS18t0vf3Gmxcgz82tJo&hl=en&sa=X&ved=0ahUKEwiqo8SCi6PPAhUJqJQKHeD7B-oQ6AEIPjAE#v=onepage&q=物理层相关内容&f=false)（这是 Google book）做更深入的了解。

## 四、数据链路层

### 4.1 数据链路层的功能

数据链路层是 OSI 参考模型中的第二层，介于物理层和网络层之间。数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层的数据可靠地传输到相邻节点的目标主机的数据链路层，使其能传至网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：

- 将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；
- 控制帧在物理信道上的传输，包括如何处理传输差错（差错校验），如何调节发送速率以使与接收方相匹配（帧同步）；
- 以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

### 4.2 帧的概述

首先什么是 **帧**，帧是数据链路层的基本传输单位，一个帧的组成是这样的：帧=帧首部+帧的数据部分+帧尾部。

| 帧的开始 | IP 数据包 | 帧的结束 | |--------|--------| | 帧首部|帧的数据部分| 帧的尾部 |

添加帧的首部与尾部的作用主要是为了方便数据的同步，差错的校验等等一系列控制操作。

这其中有个重要的概念，便是 MTU（Maximum Transfer Unit：最大传送单元），单位是 byte。MTU 是在除去添加的部分，中间数据部分最多能够存放数据的容量的值，如上述的帧结构里的 MTU 值就是 IP 数据包部分的最大容量。

广域网是由许多的局域网所构成的，而最早、最广泛的局域网是以太网，在以太网中可以传输的最大传送单元 MTU 是 1500 bytes，所以其帧的最大值是 1518 bytes。

### 4.3 帧的结构

为什么他的帧最大值是 1518 呢？这样也就是说其帧的首部与尾部的值是 18 bytes，他的具体结构是这样：

| 帧的开始 | IP 数据包 | 帧的结束 | |--------|--------| | 帧首部|帧的数据部分| 帧的尾部 | | MAC Header（物理地址头部，14 bytes） | Data（46~~1500 bytes） | CRC（差错校验部分，4 bytes） | |目的地址 | 源地址 | 类型| 数据| 循环冗余校验| |（DMAC，6 bytes）|（SMAC，6 bytes）|（type，2 bytes）|（Data，46~~1500 bytes）|（CRC，4 bytes）|

![946px-Ethernet_Type_II_Frame_format.svg.png](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474529316662.png) （图片来自于[维基百科](https://en.wikipedia.org/wiki/Ethernet_frame#/media/File:Ethernet_Type_II_Frame_format.svg)）

而实际传输的以太帧也确实是这样的结构，我们可以通过 wireshark 查看，如图所示：

![ethernet-frame-wireshark.png](https://doc.shiyanlou.com/document-uid113508labid1987timestamp1475914028997.png)

细心的同学会发现上文不是说物理层会在帧前面添加 Preamble 与 SFD 吗？为什么 wireshark 抓取的包并没有发现呢，而且 CRC 校验码也没有看见，这里只看到了 DMAC 与 SMAC 还有 type。

首先中间的数据部分就是 IP 数据包所以内容在下一层 Internet Protocol Version 4 中显示，而没有Preamble 与 SFD 以及 CRC 是因为在物理层上网卡（也就是适配器）要先去掉前导同步码和帧开始定界符（也就是 Preamble 与 SFD），然后对帧进行 CRC 检验，如果帧校验和有错，就丢弃此帧。如果校验和正确，就判断帧的目的硬件地址是否符合自己的接收条件，如果符合，就将帧做进一步处理。这时我们的抓包软件 Wireshark 才能获取数据，因此，Wireshark 获取到的数据是去掉前导同步码、帧开始分界符、FCS（也就是 CRC 校验码）之外的数据。

所以我们只能看到 DMAC 与 SMAC 和 Type 部分。

而在 OSI 参考模型中，在 Xerox 公司创立以太网，并推出了其相关的标准的几年之后，IEEE（电子电气工程师协会）802 委员会推出了一个与以太网有一点细小差别的 802.x 的标准集，他们将数据链路层又细分为 LLC（ Logical Link Control：逻辑链路控制子层，在 802.3 标准中）与 MAC（Media Access Control:媒体访问控制子层 802.2 标准中），发布在 RFC 1042 中。

- LLC：负责识别网络层的协议和对这些逻辑接口的封装，以及差错校验控制，还有帧的同步；
- MAC：负责控制对设备的接入，访问与传输数据的权限。

这是以负责对象的不同来划分的，LLC 主要是负责与网络层上的接洽，在逻辑结构、一些软件上的控制，而 MAC 主要是对物理层与硬件相关方面的控制，我们常说的 MAC 地址，也称之为 物理地址（Media Access Control address）也是由此而来的，MAC 地址是一台电脑在网络通信接口的唯一识别标志，它是固化在网络适配器（网卡）中 ROM 的地址，是全球唯一的地址，是一个 48 位（6 bytes）的地址。它是这样构成的：

![MAC-48_Address.svg.png](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474596467459.png)

一共 48 位的 MAC 地址（也就是 6 bytes），分为两部分，两部分各占据一半，

- 第一部分也就是头 24 bits 叫做组织唯一标志符（Organizationally Unique Identifier，即 OUI），是由 IEEE 的注册管理机构给不同厂家分配的代码，区分了不同的厂家。
- 第二部分也就是后 24 bits 是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中 MAC 地址后 24 位是不同的。

既然他们的标准集不同，那么帧的内容也会有一定的区别,现在常见的帧类别有以下几种：

| Frame type（帧类别） | Ethertype or length（MTU 值 ） |Payload start two bytes（内容开始的头两个字节）| |--------|--------| | Ethernet II | ≥ 1536 |Any| |Novell raw IEEE 802.3| ≤ 1500| 0xFFFF| |IEEE 802.2 LLC| ≤ 1500 |Other| |IEEE 802.2 SNAP| ≤ 1500 |0xAAAA|

我们以 SNAP（subnetwork access portocol ）为例来看：

| 帧的开始 | IP 数据包 | 帧的结束 | |--------|--------| | 帧首部|帧的数据部分| 帧的尾部 | | 802.3 MAC（14 bytes） | 802.2 LLC，802.2 SNAP，Data（逻辑控制，子网访问，数据部分，46~~1500 bytes） | CRC（差错校验部分，4 bytes） | |目的地址 | 源地址 | 类型| DSAP | SSAP | control | org code | type | 数据| 循环冗余校验| |（DMAC，6 bytes）|（SMAC，6 bytes）|（type，2 bytes）|（LLC，3 bytes，SNAP，5 bytes，Data，46~~1500 bytes）|（CRC，4 bytes）|

![SNAP](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474533130290.png)

> SNAP 是 IEEE 为保证在 802.2 LLC 上支持更多的上层协议同时更好的支持 IP 协议而发布的标准

|Size (Bytes)| Value |Description| IEEE Types| |--------|--------| |1 |AA |DSAP,Destination Service Access Point. |802.2 LLC| |1 |AA |SSAP,Source Service Access Point. |802.2 LLC| |1 or 2 |03 |Control. |802.2 LLC| |3 | |Organization Code. |802.2 SNAP| |2 | |EtherType. |802.2 SNAP|

这就是帧的结构。

### 4.4 网桥

从上文我们得知以太网主要是工作于数据链路层，而若是想要实现局域网之间的互联，也就是 LAN-to-LAN，对局域网的一个扩充，我们用到一个工具叫做网桥（bridge）。

网桥中每一个以太网称为网段（segment），网桥通过里面的转发表来传输数据（也就是对 MAC 地址与端口的映射来转发）。从而实现了局域网之间的互联，简单的网桥只有两个接口，而随着不断的发展到 20 世纪 90 年代，集成电路技术的提高出现了多接口的网桥，而它有了一个高级的名字叫：以太网交换机，又叫做二层交换机，他能够将第 2 层转发决策从软件转移到专用集成电路 (ASIC)上。 ASIC 减少了设备中的数据包处理时间，并使设备能够处理更多端口而不会降低性能。这种在第 2 层转发数据帧的方法称为存储转发交换，大大的提高了以太网的性能。后面更是发展出了三层交换机（也就是支持第三层网络层的交换机）

> **存储转发**方法是在收到整个帧并检测完帧中的错误后才作出帧的转发决策。

> **直通交换**方法在确定了传入帧的目的 MAC 地址和出口端口后就开始转发过程。这是在存储转发出现之前的转发方式

网桥虽然能够扩大网络的物理范围，扩大网络的容量，提高可靠性，但是为了防止冲突增加了时延，没有流量控制会出现帧丢失的情况，而且还可能造成网络的广播风暴。

> **广播风暴**：当广播数据充斥网络无法处理，并占用大量网络带宽，导致正常业务不能运行，甚至彻底瘫痪，这就发生了“广播风暴”。一个数据帧或包被传输到本地网段 （由广播域定义）上的每个节点就是广播；由于网络拓扑的设计和连接问题，或其他原因导致广播在网段内大量复制，传播数据帧，导致网络性能下降，甚至网络瘫痪，这就是广播风暴。

数据链路层就认识到这里，最主要的就是理解帧的含义与其结构，更具体的内容会在后续的交换机部分讲到。

在数据链路层常用的协议有 CSMA/CD 协议（Carrier Sense Multiple Access with Collision Detection）即带冲突检测的载波监听多路访问技术(载波监听多点接入/碰撞检测)，TokingRing 协议，PPP 协议（重点），ARP 协议，RARP 协议，CDP 协议，Frame Relay（帧中继），ATM，STP，VTP，LLDP 等等

ARP 协议是一个比较有争议的协议，有些同学会认为是网络层的协议，有部分的国内书籍也是这样写的，在[维基百科](https://en.wikipedia.org/wiki/Data_link_layer)中却将他列为数据链路层，部分的国外教材也是列在了数据链路层，其实不能将它独立的看在某一层中，因为 ARP 使用到了第三层与第二层的技术。

在 TCP/IP 参考模型中将其定位在数据链路层，而在 OSI 参考模型中描述为驻留在第三层网络层，在第二层数据链路层封装。（其实从功能来看的话它是对 IP 地址翻译成 MAC 地址，并且 ARP 的数据包不能路由，也没有 IP 包头，广播也是二层阶段的数据帧的广播等等一些现象证明它是一个二层的协议。我们应该把重点放在功能与实现的原理上，而属于哪一层看看如 [gregsowell](http://gregsowell.com/?p=2987)、[Learningnetwork](https://learningnetwork.cisco.com/thread/36117)的一些观点即可，不能过于纠结）。

什么是 ARP 协议呢？ARP 协议是一个非常常用也是很重要的一个协议。ARP 是 Address Resolution Protocol（地址解析协议）的缩写，从上文我们了解到在局域网中，网络中实际传输的是帧，帧里面是有目标主机的 MAC 地址的。所以在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的 MAC 地址。但这个目标 MAC 地址是如何获得的呢？它就是通过地址解析协议也就是 ARP 协议获得的。地址解析就是主机在发送帧前将目标IP地址转换成目标 MAC 地址的过程。ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的顺利进行。

我们可以做这样一个实验来看，在 GNS3 中我们往画布中拖入三台交换机，假设他们是两台主机，一台交换机，分别为 PC1、PC2、Switch1，首先修改他们的名字（还记吗？双击他们的名字或者右键 change hostname），然后修改他们的图标（右键-->change symbol）：

![switch-changesymbol.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476169295860.png)

点击 Apply 与 OK 都能达到我们的目的：

![switch-changesymbol-apply.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476169562985.png)

这样他们展现的就是pc的图标，开启他们，然后使用 Wireshark 监听抓包（还记得吗？右键线路）：

![switch-arp-capture.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476169849960.png)

接下来就是为两个连接的端口配置 IP 地址（因为这是三层交换机所以可以配置 IP 地址，工作于二层的二层交换机是没办法配置 IP 地址的），ARP 就是 IP 地址与 MAC 地址映射的一个协议，没 IP 地址怎么行呢，还记得如何为某个端口配置 IP 地址吗？

![switch-arp-config.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476170239587.png)

如同上个实验一般，PC1 与 PC2 的配置基本相同，也只有 IP 地址有所区别，上一节中有每条命令的解释还记得吗？

```
PC1#conf t

PC1(config)#int e0/0

PC1(config-if)#no swit

PC1(config-if)#ip add 192.168.1.1 255.255.255.0

PC1(config-if)#no sh

PC1(config-if)#end
PC2#conf t

PC2(config)#int e0/0

PC2(config-if)#no swit

PC2(config-if)#ip add 192.168.1.2 255.255.255.0

PC2(config-if)#no sh

PC2(config-if)#end
```

配置好了 PC，我们需要配置我们的交换机（其中会涉及到 vlan 的知识点将会在后续的交换机课程中详细讲解）：

```
#进入全局模式配置
Switch1#conf t

#首先配置 vlan，也就是划分虚拟局域网，将在后续的课程详解
Switch1(config)#vlan 2

#配置该虚拟局域网的名字
Switch1(config-vlan)#name test

#退出该配置模式
Switch1(config-vlan)#exit

#配置 SVI，同样将在后续的课程中讲解
Switch1(config)#int vlan 2

#为 SVI 接口配置 IP 地址
Switch1(config-if)#ip add 192.168.1.3 255.255.255.0

#激活这个 vlan
Switch1(config-if)#no sh

#退出这个配置模式
Switch1(config-if)#exit

#配置默认网关
Switch1(config)#ip default-gateway 192.168.1.4

#同时配置 e0/0,e0/1 两个接口
Switch1(config)#int range e0/0-1

#将两个接口划分入 vlan 2 中
Switch1(config-if-range)#switchport access vlan 2

#退出该配置模式
Switch1(config-if-range)#exit
```

然后我们使用 PC1 去 `ping 192.168.1.2`，也就是尝试联通 PC2，此时的 PC1 并不知道 PC2 在自己旁边，也不知道它的 MAC 地址，ping 了之后我们看看抓的数据包的变化，我们可以使用 wireshark 的过滤器查看 arp 的数据包：

![switch-arp-packet.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476172043427.png)

从抓取的数据包我们不难看出 ARP 的一个通讯过程：

- 首先 PC1 向 `192.168.1.2` 发起通信的请求，此时并不知道这个 IP 地址是谁，更别说 MAC 地址是多少了，而若是不知道目的 MAC 地址，在数据链路层帧的首部将空白，所以这样无法发送。ARP 会维护一张表，叫做 ARP 表，里面是 IP 地址与 MAC 地址的映射关系，这样就知道哪个 IP 对应着那个 MAC 地址了，然后系统就会看 ARP 表，发现此时的表没有关于这个 IP 地址的对应关系；
- 然后 PC1 想办法知道这个 IP 地址的 MAC 地址是多少不然数据无法发送出去，这个时候得借助大家的力量了，他就广播请求数据包（广播就是所有直连的设备都会接收到，并且会帮他转发，让同一个广播域中所有设备都收到，广播域会在后续章节中讲解），询问所有的设备，大家谁都在吗？处于开机的状态的，在网络中的设备就举手，“谁是 192.168.1.2啊，快来告诉 192.168.1.1”。因为这是一个广播的帧，所以只要收到这条帧的设备都会把它转发，比如中间的设备收到这条帧之后，看一下自己，不是这个 IP，然后将这个帧转发向自己所有的端口，当然除了没有插线的端口以及这条帧的来源端口，如例子中的 Switch1 也就是发送给了 e0/1 端口，但不发给 e0/0 这个端口，和没插线的 e0/2-e3/3。

![switch-arp-askwho.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476173095388.png)

- 因为在同一个广播域里，PC2 收到了这广播过来的帧，看了下自己的 IP，就是询问的 IP，原来是有人在找我呀，那我就告诉他，我就是这个 IP 的主人，告诉的方式就是告诉他这个 IP 地址的 MAC 地址：

![switch-arp-answer.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476173666886.png)

- 这样一来，PC1 就知道了目的 IP 地址的 MAC 地址是多少了，这样就可以发送完整的数据包了，同时 ARP 会在 ARP 表中记录下来这个 IP 与其对应的 MAC，下次发送数据的时候就不用广播询问大家了，可以直接发送的（当然 ARP 的表项是会老化的，也就是每个一定的时间就会重新发起一次 ARP 询问，看该项还在不在，若不再则删除，再就保留重置状态时间，这样可以保持 ARP 最新的状态，以及放置 ARP 表过大）。我们可以通过 `show arp` 来查看 arp 表

![switch-arp-show.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476174714364.png)

大家可能会对上面的 `Gratuitous ARP xxxxxx` 的广播帧会有疑问，这称之为免费 ARP，它发生在系统引导期间进行接口配置的时候。不同于一般的 ARP 请求，它并非期待得到 IP 对应的 MAC 地址，而是有这两个作用：

- 验证 IP 是否冲突：看在同一广播域中是否有主机的 IP 与之相同；
- 更换物理网卡：在主机更换物理网卡之后，告诉所有设备，该 IP 对应的 MAC 地址更换了，更新 ARP 表。

![switch-arp-replyeveryone.png](https://doc.shiyanlou.com/document-uid113508labid2126timestamp1476182832197.png)

这就是 ARP，以及 ARP 通讯的整个过程。中间大家会有很多不太清楚，不了解的名词，概念都会在后续的交换机课程中为大家讲解。

这只是一个粗略的认识，数据链路层涉及到的很多知识点都会在后续的试验中会遇到，只有从原理上了解这些知识点，才能更有把握的去排错，更快的理解后续一些协议上的使用与设计，大家可以通过[这篇文章](http://wiki.dzsc.com/info/4187.html)与[这本书](https://books.google.com.hk/books?id=nzoJ2QXnM9IC&pg=PA122&lpg=PA122&dq=数据链路层相关内容&source=bl&ots=he9Y1egFz6&sig=CoMhEobPWyp7J4iLdUq7PcXA6Xs&hl=en&sa=X&ved=0ahUKEwi7n8TOjKPPAhVEJpQKHSQ-BXUQ6AEIYzAI#v=onepage&q=数据链路层相关内容&f=false)做更深入的了解（这本书在Google book上）。通过 [Gitbook 上的这一篇文章](https://jack-lee-hiter.gitbooks.io/codeconcepts/content/数据链路层.html),大家可以很清晰的看到知识点的罗列，与部分协议的实现原理。

## 五、网络层

### 5.1 网络层的功能

以太网协议依靠 MAC 地址发送数据。理论上，单单依靠 MAC 地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。

但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，效率低，而且局限在发送者所在的子网络。

网络层对端到端的包传输进行了定义，它定义了能够标识所有结点的逻辑地址，伴随着一套寻址系统，还定义了路由实现的方式和学习的方式。由此每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是管理员分配的。网络地址帮助我们确定计算机所在的子网络，MAC地址则帮助定位该子网络中的目标网卡。

规定网络地址的协议，叫做 IP 协议（Internet Protocol：网际协议），它所定义的地址，就被称为 IP 地址，同时其定义了数据包的格式。

IP 是网络层中的核心协议，也是 TCP/IP 协议簇中的最核心协议之一。

### 5.2 IP 协议

对于 Internet Protocol 需要注意这样几件事：

- IP 协议是无连接类型的；
- IP 协议采用的是 best-effort 的方法，却不能保证丢包与乱序的不会发生。

> - **面向连接**：在面向连接的方法中，网络负责顺序发送分组报文分组并且以一种可靠的方法检测丢失和冲突。
> - **无连接**：在无连接的方法中，网络只需要将报文分组发送到接收点，检测与数据流控制由发送方和接收方处理。这种方法被称作“最佳工作(best-effort)”或“无应答(unacknowledged)”的传输协议所使用。

早在 1977 年就发布了 IP 协议的第一个版本，直到 1979 年发布到了第三个版本，而这三个版本都是实验性的，并没有大范围的使用，而到了第四个版本就是我们常见的 IPv4 （Internet Protocol version 4），设计的完善而被大规模的使用，直至今日，而 IPv4 有个缺陷也是被早早的发现，就是他会被消耗殆尽。所以科学家们也并没有闲着，继续研究着， version 5 被用于 Internet Stream Protocol，一种实验性的流协议（streaming protocol）。

到了 IPv6，作为 IPv4 的继承者开发出来 ，这个版本与 IPv4 的最大区别点在于地址的多少，IPv4 的地址是由 32 bits 组成的，因此只有 4.3*10^9 个地址（2^32=4,294,967,296。也就是43亿个）。其中有很大一部分被用于研究用，多播，还有一些专用，所以能被分配给用户的很有限。

IPv6 是由 128 bits 组成的，因此有3.4×10^38 个地址（2^128=340,282,366,920,938,463,463,374,607,431,768,211,456个地址）。

### 5.3 IPv4 地址

接下来我们就来看看 IPv4 的地址是如何组成的：

IPv4 中 IP 由 32 位组成，但是那样不便于理解与记忆，所以就采用了点分十进制的形式，也就是四个字节被分开用十进制表示，直接用点来分割开。因为每个字节是由 8 位组成，所以一个字节的最大值是 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0=2^8-1=255（8位二进制数的最大值）,所以每个字节的取值范围只能在 0~255 之间。

最初，一个IP地址被分成两部分：

- 网络号：用于区别不同的物理网络；
- 主机号：在同一个物理网络中区别不同的主机。

在随后出现的分类网络中，地址的高位字节被重定义为网络的类(Class)。这个系统定义了五个类别：A、B、C、D和E。A、B和C类有不同长度的网络号，剩余的部分被用来识别网络内的主机，这就意味着每个网络类别有着不同的给主机编址的能力。D类被用于多播地址，E类被留作将来使用。

那分类网络是如何分类的呢？A，B，C，D，E 五类的地址范围又是如何得来的呢？

A 类地址的第一位固定为 0，用来分割，后面七位为网络号，这是第一个字节，剩下的 24 位，也就是 3 个字节用作主机号：

| 0 位 | 1-7 位 | 8-31 位| |--------|--------| | 0 | 网络号 | 主机号 |

当网络号最小值 1 （因为全 0 的网络号有特殊的作用），最大值 126（因为127 被用作环回地址所以只能取到 126），主机号去最小值全零，与最大值全一，可以得到其取值范围（地址的换算涉及到进制转换，忘记了[这里可以复习下](http://www.cnblogs.com/gaizai/p/4233780.html)）

![ip address](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474613719526.png)

根据网络号我们可以得出 A 类地址允许有 2^7-2=126 个网络，根据主机号得出每个网络可以有 2^24-2=16777214 个主机

B 类地址与之类似，但是其头两位是 10，其后的 14 位是网络号，剩余的 16 位是主机号：

| 0-1 位 | 2-15 位 | 16-31 位| |--------|--------| | 10 | 网络号 | 主机号 |

![class b](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474615954789.png)

根据网络号我们可以得出 B 类地址允许有 2^14=16384 个网络，根据主机号得出每个网络可以有 2^16-2=16777214 个主机

C 类地址与之类似，但是其头三位是 110，其后的 21 位是网络号，剩余的 8 位是主机号：

| 0-2 位 | 3-23 位 | 24-31 位| |--------|--------| | 110 | 网络号 | 主机号 |

![class c](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474615981354.png)

根据网络号我们可以得出 C 类地址允许有 2^21=2097152 个网络，根据主机号得出每个网络可以有 2^8-2=254 个主机

D 类地址与之类似，但是其头三位是 1110，但是不表示网络，一般用于其他的用途，其地址范围是 224.0.0.0~239.255.255.255

E 类的 IP 地址尚未使用，其地址范围是 240.0.0.0~247.255.255.255。

还有一些特殊用途的 IP 地址：

| CIDR 地址块     | 描述                         | 参考资料 |
| --------------- | ---------------------------- | -------- |
| 0.0.0.0/8       | 本网络（仅作为源地址时合法） | RFC 5735 |
| 10.0.0.0/8      | 专用网络                     | RFC 1918 |
| 127.0.0.0/8     | 环回                         | RFC 5735 |
| 169.254.0.0/16  | 链路本地                     | RFC 3927 |
| 172.16.0.0/12   | 专用网络                     | RFC 1918 |
| 192.0.0.0/24    | 保留（IANA）                 | RFC 5735 |
| 192.0.2.0/24    | TEST-NET-1，文档和示例       | RFC 5735 |
| 192.88.99.0/24  | 6to4 中继                    | RFC 3068 |
| 192.168.0.0/16  | 专用网络                     | RFC 1918 |
| 198.18.0.0/15   | 网络基准测试                 | RFC 2544 |
| 198.51.100.0/24 | TEST-NET-2，文档和示例       | RFC 5737 |
| 203.0.113.0/24  | TEST-NET-3，文档和示例       | RFC 5737 |
| 224.0.0.0/4     | 多播（之前的D类网络）        | RFC 3171 |
| 240.0.0.0/4     | 保留（之前的E类网络）        | RFC 1700 |
| 255.255.255.255 | 广播                         | RFC 919  |

### 5.4 子网划分

子网（Subnetwork）指的是将一个大型的网络切分为逻辑上的多个小的网络组。在最初引入这个概念的时候，IPv4 还未引入分类网络这个概念。而引入划分子网这个概念的目的是为了允许一个单一的站点能拥有多个局域网。即使在引入了分类网络号之后，这个概念仍然有它的用处，因为它减少了因特网路由表中的表项数量。此外它还带来了一个好处，那就是减少了网络开销，因为它将接收 IP 广播的区域划分成了若干部分（广播是将一条消息向本局域网内所有的节点发送）。

若是划分了子网，IP 地址中需要有位置来标识子网，那么 IP 的组成变成了三部分：网络号、子网号、主机号，但是光从表面上无法看出 IP 地址是被划分了子网的，由此便发明了一个东西来给子网号带来存在感，这个东西叫做网络掩码又叫子网掩码（subnet mask），它是一种用来指明一个 IP 地址中哪一部分是网络号位，若是网络号位的长度与标准的不同，那么便表示子网的存在。

子网掩码的表示是：在 IP 地址的二进制表示法中，只要表示为网络号与子网号的位置，在子网掩码的二进制表示与之对应的位置都标识为 1。换算成十进制的为点分四组表示。例如在一个 A 类网络中的 IP 地址 `10.1.1.0`，上文说到其前八位都为网络号位，所以其子网掩码的二进制表示法应该是 `11111111 00000000 00000000 00000000`，换算为十进制便是 `255.0.0.0`，他的可变长子网掩码 VLSM 表示法是 `10.1.1.0/8`。

所以通常 A、B、C 三类地址还未划分子网时他们的标准子网掩码是：

| 地址类型 | 标准的子网掩码 | CIDR表示| |--------|--------| | A 类 | 255.0.0.0 | ip/8| | B 类 | 255.255.0.0 | ip/16| | C 类 | 255.255.255.0 | ip/24|

此时我们会有疑问，标准子网掩码是如何确定下来？又如何区分划分了子网的 IP？

子网掩码的值与 `固定值位+网络号+子网号` 的位数相关（固定值位就如 A 类，开头占了 1 位，B 类开头占了 2 位，C 类开头占据了 3 位），若是没有划分子网，便没有子网号，此时 `子网掩码中标志为 1 的位数 = 固定值位+网络号位`，这是一个参考值，所以叫做标准子网掩码。若是划分了子网掩码，那么必然有子网号了，此时 `子网掩码中标志为 1 的位数 = 固定值位+网络号位+子网号位`，那么与标准的子网掩码不同，就可以推算出它划分了子网，子网号有几位。

所以没有划分子网的 A 类地址 固定值位+网络号 有 8 位，所以其标准子网掩码就是 `255.0.0.0`，二进制是 `11111111 00000000 00000000 00000000`，VLSM 的表示就是 ip/8，同理 B 类地址占据了 16 位，所以其标准的子网掩码是 `255.255.0.0`。

这样好像明白一点了，但是该怎么用？我们举这样一个例子：

一个公司他有一个 C 类的地址，假设 IP 地址所在的网段是 192.168.15.0，他有 10 家子公司，每个子公司都要独立的子网，此时我们该如何确定子网掩码，以及每个子网的范围呢？

![subnet](https://doc.shiyanlou.com/document-uid113508labid2122timestamp1474623623445.png)

这就是子网的划分，大家可以尝试一下能否通过子网掩码反推出当前的子网号所占据的位数，可以划分多少个子网，主机位占据了多少位，每个子网可以容纳多少台主机。

在数据链路层传输的是数据帧，而在网络层传输的是数据包，而数据包便是在上层的数据前加上了 IP 报头，它的格式如图所示：

![ip-header-v41.png](https://doc.shiyanlou.com/document-uid113508labid1timestamp1474874260169.png) （此图来自于 [FOREN6 的 wordpress](https://foren6.files.wordpress.com/2011/04/ip-header-v41.png)）

我们可以通过这篇[文章](http://www.2cto.com/net/201604/498569.html)了解，报头中的每个信息的含义与意义，文章中的实验我们用上文 ARP 实验的环境即可，主要是对 ICMP（ping 工具便是对 ICMP 协议的是一个实现） 中 IP 包头的分析。

### 5.5 IPv6

虽然现在绝大部分的人们还在使用 IPv4，对 IPv6 的概念与认知度似乎并没有这么的高，但是 IPv4 与 IPv6 的过渡仍然在有条不紊的进行中，并且 IPv6 的使用也是势在必行的，毕竟 IPv4 的地址匮乏是不可逆的，即使使用了各种方式在减缓这个速度，1994 年选中了 IPv6 的提议，在 1995 年 日本最大的因特网研究社团 WIDE（Widely Integrated Distributed Environment：广泛集成的分布式环境）项目成立了 IPv6 工作组，对 IPv6 进行了大量深入的开发，在 98 年启动了 KAME 项目，加速了 IPv6 的部署与发展。IPv6 的项目是开源的，有兴趣的同学可以在网上找到相关的源代码。

IPv6 同时也成为 CCNA 考试中的一项，由此也可以看出厂商们对 IPv6 的重视，IPv6 的广泛普并不会太过遥远。

IPv6 是以 16 进制值来书写的，被 7 个冒号分隔成 8 组，每组 2 个字节，所以 IPv6 的地址是由 8 组十六进制段来组成的，例如：

2001:0DB8:0123:4567:89ABCD:B3FF:FE1E:8329

需要注意的有：

- 每个十六进制段的值是大小写无关的
- 为了简化，可以忽略每组十六进制段中的前导0，如上例子中的 0DB8，可以直接写成 DB8
- 双冒号可以代替连续的 0，但是每个地址中只能出现一次双冒号。如 0000:0000:0000:0000:0000:0000:0000:0001这个地址的简化写法，可以直接写成 ::1。
- 在 IPv4 与 IPv6 的混合网络环境中，有一种简便的 IPv6 表达式，就是将 IPv4 地址放到 IPv6 地址的 4 个低阶字节。例如 ::ffff:192.168.1.1。`::ffff:1.2.3.4` 格式叫做 IPv4 映射地址。而 `::1.2.3.4` 格式叫做IPv4一致地址，目前已被取消。

在很多场合，IPv6地址由两个逻辑部分组成：一个64位的网络前缀和一个64位的主机地址，网络前缀与 IPv4 的 VLSM 的表示方法类似，`地址/前缀的比特位数量`，主机地址通常根据物理地址自动生成，叫做 EUI-64（或者64-位扩展唯一标识）

而 IPv6 的 header 与 IPv4 也有所不同，在 IPv6 中做了简化，如图所示：

![ipv6 header format](https://doc.shiyanlou.com/document-uid113508labid1timestamp1474874923505.png) （此图来自于[openwsn](https://openwsn.atlassian.net/wiki/download/attachments/688230/ipv6_header.png?version=1&modificationDate=1353368373743&api=v2)）

其中的各个字段分别为：

- Version（版本号）：4位，IP协议版本号，值= 6。
- Traffic Class（通信类别）：8位，指示IPv6数据流通信类别或优先级。功能类似于IPv4的服务类型（TOS）字段。
- Flow Label（流标记）：20位，IPv6 新增字段，标记需要IPv6路由器特殊处理的数据流。该字段用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据传输。在IPv6中，同一信源和信宿之间可以有多种不同的数据流，彼此之间以非“0”流标记区分。如果不要求路由器做特殊处理，则该字段值置为“0”。
- Payload Length（负载长度）：16位负载长度。负载长度包括扩展头和上层PDU，16位最多可表示65535字节负载长度。超过这一字节数的负载，该字段值置为“0”，使用扩展头逐个跳段（Hop-by-Hop）选项中的巨量负载（Jumbo Payload）选项。
- Next Header（下一包头）：8位，识别紧跟IPv6头后的包头类型，如扩展头（有的话）或某个传输层协议头（诸如TCP，UDP或着ICMPv6）。
- Hop Limit（跳段数限制）：8位，类似于IPv4的TTL（生命期）字段，用包在路由器之间的转发次数来限定包的生命期。包每经过一次转发，该字段减1，减到0时就把这个包丢弃。
- Source Address（源地址）：128位，发送方主机地址。
- Destination Address（目的地址）：128位，在大多数情况下，目的地址即信宿地址。但如果存在路由扩展头的话，目的地址可能是发送方路由表中下一个路由器接口。

IPv6 地址主要分为这样 3 种类型：

- 单播（unicast）：一个单播 IPv6 地址标识一个网络接口。协议会把送往地址的数据包投送给其接口。IPv6的单播地址可以有一个代表特殊地址名字，如link-local地址和唯一区域地址（ULA，unique local address）。
- 任播（anycast）：任播 IPv6 地址标识一组网络接口，是 IPv6 特有的一种数据发送方式。它像是IPv4 的 Unicast（单点传播）与 Broadcast（多点广播）的综合。单点传播是在来源和目的地间直接进行通信；多点广播是单一来源和多个目的地进行通信。而 Anycast 任播则在以上两者之间，它会有一组接收节点的地址栏表。但是指定为 Anycast 的数据包，只会发送给距离最近或发送成本最低（根据路由表来判断）的其中一个接收地址，当该接收地址收到数据包并进行回应，便加入后续的传输。该接收列表的其他节点，会知道哪些节点地址已经回应了，以防止重复的发送
- 多播（multicast）：也称组播地址。标识一组通常位于不同节点上的接口。发送到多播地址的包将传递到多播组的所有成员。多播地址由皆为一的字节起始，亦即：它们的前置为 FF00::/8。

总的来说 IPv6 有这样一些特性：

- 极大扩展的地址空间：地址格式从 32 比特扩展到 128 比特；
- 自动配置：就是无状态自动配置机制；
- 简化了报头格式：与 IPv4 报头相比，IPv6 报头更为简单，长度固定为 40 字节；
- 增强了选项与扩展报头的支持：IPv4 将选项集成到基本报头中，IPv6 则通过所谓的扩展报头来承载选项；
- 流标签的使用：让我们可以为数据包所属类型提供个性化的网络服务；
- 认证与私密性：IPv6 把 IPSec 作为必备协议，保证了网络层端到端通信的完整性和机密性；
- IPv6 在移动网络和实时通信方面有很多改进。

IP地址介绍到这里，更多的深入了解将在后续课程中。而在网络层常用的协议有：

- EIGRP（Enhanced Interior Gateway Routing Protocol）
- ICMP Internet Control Message Protocol
- IGMP Internet Group Management Protocol
- IGRP Interior Gateway Routing Protocol
- IPv4 Internet Protocol version 4
- IPv6 Internet Protocol version 6
- IPSec Internet Protocol Security
- IPX Internetwork Packet Exchange
- GRE Generic Routing Encapsulation for tunneling
- OSPF Open Shortest Path First
- RIP Routing Information Protocol

这只是一个粗略的认识，网络层涉及到的许多协议都会在后续的试验中会遇到，只有从原理上了解这些知识点，才能更有把握的去排错，更快的理解后续一些协议上的使用与设计，IPv6 更多的相关知识可以去 [思科网络学习空间](http://www.clnchina.com.cn/professional_certs/2011/0221/10963.shtml)与[异步社区](http://www.epubit.com.cn/book/onlinechapter/27373) 查看相关的资料做更深入的了解与学习。

## 六、实验总结

通过本实验会对 OSI 参考模型的前三层有个更为详细的一个认识，这其中数据链路层与网络层是我们将来学习的重点，如帧，令牌环网，CSMA/CD（带冲突检测的载波侦听多路访问），IPv4，IPv6 的报文解析等等，很多细节方面的内容、协议并没有给大家做更深入的认识，会在后续使用时再做学习，而基础的知识是为未来的学习协议与使用的铺垫，希望大家定要理解相关概念。

## 七、参考资料

[1] 百度百科 物理层:http://baike.baidu.com/view/239585.htm#reference-[2]-239585-wrap [2] 维基百科 OSI:https://en.wikipedia.org/wiki/OSI_model [3] Gitbook 网络层:http://www.laikanshu.top/books/books/13/48446.html [4] 维基百科 以太网帧:https://en.wikipedia.org/wiki/Ethernet_frame

## 八、课后作业

一个 B 类地址：172.25.0.0，若是其子网掩码是 255.255.224.0。请计算其子网号有多少位，可以划分多少子网，每个子网中有多少台主机，每个子网的 ip 地址范围是多少？